Microsoft (R) Macro Assembler Version 6.14.8444		    06/30/00 13:01:25
xdraw3.asm						     Page 1 - 1


				;; THIS SOFTWARE IS SUBJECT TO COPYRIGHT PROTECTION AND IS OFFERED ONLY
				;; PURSUANT TO THE 3DFX GLIDE GENERAL PUBLIC LICENSE. THERE IS NO RIGHT
				;; TO USE THE GLIDE TRADEMARK WITHOUT PRIOR WRITTEN PERMISSION OF 3DFX
				;; INTERACTIVE, INC. A COPY OF THIS LICENSE MAY BE OBTAINED FROM THE 
				;; DISTRIBUTOR OR BY CONTACTING 3DFX INTERACTIVE INC(info@3dfx.com). 
				;; THIS PROGRAM IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER 
				;; EXPRESSED OR IMPLIED. SEE THE 3DFX GLIDE GENERAL PUBLIC LICENSE FOR A
				;; FULL TEXT OF THE NON-WARRANTY PROVISIONS.  
				;; 
				;; USE, DUPLICATION OR DISCLOSURE BY THE GOVERNMENT IS SUBJECT TO
				;; RESTRICTIONS AS SET FORTH IN SUBDIVISION (C)(1)(II) OF THE RIGHTS IN
				;; TECHNICAL DATA AND COMPUTER SOFTWARE CLAUSE AT DFARS 252.227-7013,
				;; AND/OR IN SIMILAR OR SUCCESSOR CLAUSES IN THE FAR, DOD OR NASA FAR
				;; SUPPLEMENT. UNPUBLISHED RIGHTS RESERVED UNDER THE COPYRIGHT LAWS OF
				;; THE UNITED STATES.  
				;; 
				;; COPYRIGHT 3DFX INTERACTIVE, INC. 1999, ALL RIGHTS RESERVED
				
				TITLE   xdraw3.asm
				.586P
				.MMX
				.K3D    
				
				EXTRN   __GlideRoot:DWORD
				EXTRN   __grValidateState:NEAR
				EXTRN   __grCommandTransportMakeRoom@12:NEAR    
				
				ifdef GL_AMD3D
				
				;;--------------------------------------------------------------------------
				;; start AMD3D version
				;;--------------------------------------------------------------------------
				
				;;; include listing.inc
				INCLUDE fxgasm.h
				    
				CONST   SEGMENT
				        ALIGN 8
				_F256_F256      DQ    04380000043800000h ; 256 | 256
				CONST   ENDS
				
				_DATA   SEGMENT
				        ALIGN   8
				btab            DD    8 DUP(0)
				atab            DD    8 DUP(0)
				vSize           DD    0
				strideinbytes   DD    0
				vertices        DD    0
				_DATA    ENDS
				
				
				_TEXT         SEGMENT PAGE PUBLIC USE32 'CODE'
				              ASSUME DS: FLAT, SS: FLAT
				
				            ALIGN 32
				PUBLIC  __grDrawTriangles_3DNow@12
				_mode     = 20
				_count    = 24
				_pointers = 28
				__grDrawTriangles_3DNow@12 PROC NEAR
				
				; 930  : {
				; 931  : #define FN_NAME "_grDrawTriangles"
				; 932  : 
				; 933  :   FxI32
				; 934  : #ifdef GLIDE_DEBUG
				; 935  :     vSize,
				; 936  : #endif
				; 937  :     k;
				; 938  :   FxI32 stride = mode;
				; 939  :   float *vPtr;
				; 940  : 
				; 941  :   GR_BEGIN_NOFIFOCHECK(FN_NAME, 90);
				; 942  : 
				; 943  :   GDBG_INFO_MORE(gc->myLevel, "(count = %d, pointers = 0x%x)\n",
				; 944  :                  count, pointers);
				; 945  : 
				; 946  :   GR_FLUSH_STATE();
				
				gc            TEXTEQU  <edi>             ; points to graphics context
				fifo          TEXTEQU  <ecx>             ; points to next entry in fifo
				dlp           TEXTEQU  <ebp>             ; points to dataList structure
				vertexCount   TEXTEQU  <esi>             ; Current vertex counter in the packet
				vertexPtr     TEXTEQU  <ebx>             ; Current vertex pointer (in deref mode)
				vertex        TEXTEQU  <ebx>             ; Current vertex (in non-deref mode)
				dlpStart      TEXTEQU  <edx>             ; Pointer to start of offset list
				
				    push      edi                        ; save caller's register variable
				    mov       eax, DWORD PTR fs:[18h]    ; get thread local storage base pointer
				
				    push      esi                        ; save caller's register variable
				    mov       edx, [__GlideRoot+tlsOffset]; offset of GC into tls
				
				    push      ebx                        ; save caller's register variable
				    mov       vertexCount, [esp+_count-4]; number of vertices in triangles
				
				    mov       gc, [eax+edx]              ; get GC for current thread 
				    mov       vertexPtr, [esp+_pointers-4]; get current vertex pointer (deref mode)
				
				    push      ebp                        ; save frame pointer
				    mov       edx, [gc + invalid]        ; state needs validation ?
				
				    test      vertexCount, vertexCount   ; number of vertices <= 0 ?
				    jle       $tris_done                 ; yup, triangles are done
				
				    test      edx, edx                   ; do we need to validate state ?
				    je        $no_validation             ; nope, it's valid
				
				    call      __grValidateState          ; validate state
				
				$no_validation:
				
				; 947  : 
				; 948  : #ifdef GLIDE_DEBUG
				; 949  :   GDBG_INFO(110, "%s:  vSize = %d\n", FN_NAME, vSize);
				; 950  : 
				; 951  :   GDBG_INFO(110, "%s:  paramMask = 0x%x\n", FN_NAME, gc->cmdTransportInfo.paramMask);
				; 952  : #endif
				; 953  : 
				; 954  :   if (stride == 0)
				; 955  :     stride = gc->state.vData.vStride;
				; 956  : 
				; 957  : 
				; 958  :   _GlideRoot.stats.trisProcessed+=(count/3);
				; 959  : 
				; 960  :   if (gc->state.grCoordinateSpaceArgs.coordinate_space_mode == GR_WINDOW_COORDS) {
				
				;; We can operate in one of two modes:
				;;
				;; 0. We are stepping through an array of vertices, in which case
				;; the stridesize is equal to the size of the vertex data, and
				;; always > 4, since vertex data must a least contain x,y (ie 8 bytes).
				;; vertexPtr is pointing to the array of vertices.
				;;
				;; 1. We are stepping through an array of pointers to vertices
				;; in which case the stride is 4 bytes and we need to dereference
				;; the pointers to get at the vertex data. vertexPtr is pointing
				;; to the array of pointers to vertices.
				
				    mov       eax, [esp + _count]        ; count
				    mov       ebp, 0AAAAAAABh            ; 1/3*2^32*2
				
				    femms                                ; we'll use MMX; clear MMX/3DX state      
				
				    mul       ebp                        ; edx:eax = 1/3*2*2^32*count; edx = 1/3*2*count
				    nop                                  ; filler
				
				    mov       eax, [gc + trisProcessed]  ; trisProcessed
				    shr       edx, 1                     ; count/3
				
				    add       eax, edx                   ; trisProcessed += count/3
				    mov       edx, [esp + _mode]         ; get mode (0 or 1)
				
				    mov       ecx, [gc + CoordinateSpace]; coordinates space (window/clip)
				    mov       [gc + trisProcessed], eax  ; trisProcessed
				
				    test      edx, edx                   ; mode 0 (array of vertices) ?
				    jnz       $deref_mode                ; nope, it's mode 1 (array of pointers to vertices)
				
				    mov       edx, [gc + vertexStride]   ; get stride in DWORDs
				
				    shl       edx, 2                     ; stride in bytes
				    test      ecx, ecx                   ; coordinate space == 0 (window) ?
				
				    mov       [strideinbytes], edx       ; save off stride (in bytes)
				    jnz       $clip_coordinates_ND       ; nope, coordinate space != window  
				
				; 961  :     while (count > 0) {
				; 962  :       FxI32 vcount = count >=15 ? 15 : count;
				; 963  :       GR_SET_EXPECTED_SIZE(vcount * gc->state.vData.vSize, 1);
				; 964  :       TRI_STRIP_BEGIN(kSetupStrip, vcount, gc->state.vData.vSize, SSTCP_PKT3_BDDBDD);
				; 965  :       
				
				$win_coords_loop_ND:
				
				    sub       vertexCount, 15            ; vertexCount >= 15 ? CF=0 : CF=1
				    mov       ecx, [gc + vertexSize]     ; bytes of data for each vertex 
				
				    sbb       eax, eax                   ; vertexCount >= 15 ? 00000000:ffffffff
				
				    and       vertexCount, eax           ; vertexCount >= 15 ? 0 : vertexcount-15
				    add       vertexCount, 15            ; vertexcount >= 15 ? 15 :vertexcount
				
				    imul      ecx, vertexCount           ; total amount of vertex data we'll send
				
				    mov       eax, [gc + fifoRoom]       ; fifo space available
				    add       ecx, 4                     ; add header size ==> total packet size
				
				    cmp       eax, ecx                   ; fifo space avail >= packet size ?
				    jge       $win_tri_begin_ND          ; yup, start writing triangle data
				
				    push      @Line                      ; line number inside this function
				    push      0h                         ; pointer to function name = NULL
				
				    push      ecx                        ; fifo space needed
				    call      __grCommandTransportMakeRoom@12 ; note: updates fifoPtr
				
				        align   32
				$win_tri_begin_ND:
				
				    mov       eax, vertexCount           ; number of vertices in triangles
				    mov       fifo, [gc + fifoPtr]       ; get fifoPtr
				
				    mov       ebp, [gc + cullStripHdr]   ; <2:0> = type
				    shl       eax, 6                     ; <9:6> = vertex count (max 15)
				
				    lea       dlpStart, [gc+tsuDataList] ; pointer to start of offset list
				    or        eax, ebp                   ; setup vertex count and type
				
				    test      fifo, 4                    ; fifoPtr QWORD aligned ?
				    jz        $fifo_aligned_ND           ; yup
				
				    mov       [fifo], eax                ; PCI write packet type
				    add       fifo, 4                    ; fifo pointer now QWORD aligned
				
				; 966  :       for (k = 0; k < vcount; k++) {
				; 967  :         FxI32 i;
				; 968  :         FxU32 dataElem = 0;
				; 969  :         
				; 970  :         vPtr = pointers;
				; 971  :         if (mode)
				; 972  :           vPtr = *(float **)vPtr;
				; 973  :         (float *)pointers += stride;
				; 974  :         
				; 975  :         i = gc->tsuDataList[dataElem];
				; 976  :         
				; 977  :         TRI_SETF(FARRAY(vPtr, 0));
				; 978  :         TRI_SETF(FARRAY(vPtr, 4));
				; 979  :         while (i != GR_DLIST_END) {
				; 980  :           TRI_SETF(FARRAY(vPtr, i));
				; 981  :           dataElem++;
				; 982  :           i = gc->tsuDataList[dataElem];
				; 983  :         }
				; 984  :       }
				; 985  :       TRI_END;
				; 986  :       GR_CHECK_SIZE();
				; 987  :       count -= 15;
				; 988  :     }
				
				$win_vertex_loop_ND_WB0:                 ; nothing in "write buffer"
				
				    mov       eax, [dlpStart]            ; get first offset from offset list
				    mov       dlp, dlpStart              ; point to start of offset list
				
				    movq      mm1, [vertex]              ; get vertex x,y
				    add       fifo, 8                    ; fifoPtr += 2*sizeof(FxU32)
				
				    add       dlp, 4                     ; dlp++
				    test      eax, eax                   ; if offset == 0, end of list
				
				    movq      [fifo-8], mm1              ; PCI write x, y
				    jz        $win_datalist_end_ND_WB0   ; no more vertex data, nothing in "write buffer" 
				
				$win_datalist_loop_ND_WB0:               ; nothing in "write buffer"
				
				    movd      mm1, [vertex + eax]        ; get next parameter
				    mov       eax, [dlp]                 ; get next offset from offset list
				
				    test      eax, eax                   ; at end of offset list (offset == 0) ?
				    jz        $win_datalist_end_ND_WB1   ; exit, write buffer contains one DWORD
				
				    movd      mm2, [vertex + eax]        ; get next parameter
				    add       dlp, 8                     ; dlp++
				
				    mov       eax, [dlp-4]               ; get next offset from offset list
				    add       fifo, 8                    ; fifoPtr += 2*sizeof(FxU32)
				
				    test      eax, eax                   ; at end of offset list (offset == 0) ?
				    punpckldq mm1, mm2                   ; current param | previous param
				
				    movq      [fifo-8], mm1              ; PCI write current param | previous param
				    jnz       $win_datalist_loop_ND_WB0  ; nope, copy next parameter
				
				$win_datalist_end_ND_WB0:
				
				    mov       eax, [strideinbytes]       ; get offset to next vertex
				    dec       vertexCount                ; another vertex done. Any left?
				
				    lea       vertex, [vertex + eax]     ; points to next vertex
				    jnz       $win_vertex_loop_ND_WB0    ; yup, output next vertex
				
				$win_vertex_end_ND_WB0:
				
				    mov       eax, [gc + fifoPtr]        ; old fifoPtr
				    mov       ebp, [gc + fifoRoom]       ; old number of bytes available in fifo
				
				    mov       vertexCount, [esp + _count]; remaining vertices before previous loop
				    sub       eax, fifo                  ; old fifoPtr - new fifoPtr (fifo room used)
				
				    mov       [gc + fifoPtr], fifo       ; save current fifoPtr 
				    add       ebp, eax                   ; new number of bytes available in fifo
				
				    sub       vertexCount, 15            ; remaining number of vertices to process
				    mov       [gc + fifoRoom], ebp       ; save current number of bytes available in fifo
				
				    mov       [esp + _count], vertexCount; remaining number of vertices to process 
				    test      vertexCount, vertexCount   ; any vertices left to process ?
				
				    nop                                  ; filler
				    jg        $win_coords_loop_ND        ; loop if number of vertices to process >= 0
				
				    femms                                ; no more MMX code; clear MMX/FPU state
				
				    pop       ebp                        ; restore frame pointer
				    pop       ebx                        ; restore caller's register variable
				
				    pop       esi                        ; restore caller's register variable
				    pop       edi                        ; restore caller's register variable
				
				    ret       12                         ; return, pop 3 DWORD parameters off stack
				
				$fifo_aligned_ND:
				
				    movd      mm1, eax                   ; move header into "write buffer"
				
				$win_vertex_loop_ND_WB1:                 ; one DWORD in "write buffer"
				
				    movd      mm2, [vertex]              ; 0 | x of vertex
				    add       fifo, 8                    ; fifoPtr += 2*sizeof(FxU32)
				
				    lea       dlp, [dlpStart + 4]        ; point to start of offset list
				    nop                                  ; filler
				
				    punpckldq mm1, mm2                   ; packet header | x of vertex
				    mov       eax, [dlp-4]               ; first offset in offset list
				
				    movq      [fifo-8], mm1              ; PCI write packet header | x of vertex
				    movd      mm1, [vertex+4]            ; 0 | y of vertex
				
				    cmp       eax, 0                     ; offset == 0 (list empty) ?
				    jz        $win_datalist_end_ND_WB1   ; yup, no more vertex data, one DWORD in "write buffer"
				
				$win_datalist_loop_ND_WB1:               ; one DWORD in "write buffer" 
				
				    movd      mm2, [vertex + eax]        ; get next parameter
				    add       fifo, 8                    ; fifoPtr += 2*sizeof(FxU32)
				
				    mov       eax, [dlp]                 ; get next offset from offset list
				    add       dlp, 8                     ; dlp += 2
				
				    punpckldq mm1, mm2                   ; current param | previous param
				    cmp       eax, 0                     ; at end of offset list (offset == 0) ?
				
				    movq      [fifo-8], mm1              ; PCI write current param | previous param
				    jz        $win_datalist_end_ND_WB0   ; yes, exit, "write buffer" empty
				
				    movd      mm1, [vertex + eax]        ; get next parameter
				    mov       eax, [dlp-4]               ; get next offset from offset list
				
				    cmp       eax, 0                     ; at end of offset list (offset == 0) ?
				    jnz       $win_datalist_loop_ND_WB1  ; nope, copy next parameter
				
				$win_datalist_end_ND_WB1:
				
				    mov       eax, [strideinbytes]       ; get offset to next vertex
				    dec       vertexCount                ; another vertex done. Any left?
				
				    lea       vertex, [vertex + eax]     ; points to next vertex
				    jnz       $win_vertex_loop_ND_WB1    ; yup, output next vertex
				
				$win_vertex_end_ND_WB1:
				
				    movd      [fifo], mm1                ; flush "write buffer"
				    mov       eax, [gc + fifoPtr]        ; old fifoPtr
				
				    add       fifo, 4                    ; fifoPtr += sizeof(FxU32)
				    mov       ebp, [gc + fifoRoom]       ; old number of bytes available in fifo
				
				    mov       vertexCount, [esp + _count]; remaining vertices before previous loop
				    sub       eax, fifo                  ; old fifoPtr - new fifoPtr (fifo room used)
				
				    mov       [gc + fifoPtr], fifo       ; save current fifoPtr 
				    add       ebp, eax                   ; new number of bytes available in fifo
				
				    mov       [gc + fifoRoom], ebp       ; save current number of bytes available in fifo
				    sub       vertexCount, 15            ; remaining number of vertices to process
				
				    mov       [esp + _count], vertexCount; remaining number of vertices to process 
				    test      vertexCount, vertexCount   ; any vertices left to process ?
				
				    nop                                  ; filler
				    jg        $win_coords_loop_ND        ; loop if number of vertices to process >= 0
				
				    femms                                ; no more MMX code; clear MMX/FPU state
				
				    pop       ebp                        ; restore frame pointer
				    pop       ebx                        ; restore caller's register variable
				
				    pop       esi                        ; restore caller's register variable
				    pop       edi                        ; restore caller's register variable
				
				    ret       12                         ; return, pop 3 DWORD parameters off stack
				
				    align 32
				
				$deref_mode:
				
				    prefetch  [vertexPtr]                ; pre-load first group of pointers
				
				    test      ecx, ecx                   ; coordinate space == 0 (window) ?
				    jnz       $clip_coordinates_D        ; nope, coordinate space != window
				
				$win_coords_loop_D:
				
				    sub       vertexCount, 15            ; vertexCount >= 15 ? CF=0 : CF=1
				    mov       ecx, [gc + vertexSize]     ; bytes of data for each vertex 
				
				    sbb       eax, eax                   ; vertexCount >= 15 ? 00000000:ffffffff
				
				    and       vertexCount, eax           ; vertexCount >= 15 ? 0 : vertexcount-15
				    add       vertexCount, 15            ; vertexcount >= 15 ? 15 :vertexcount
				
				    imul      ecx, vertexCount           ; total amount of vertex data we'll send
				
				    mov       eax, [gc + fifoRoom]       ; fifo space available
				    add       ecx, 4                     ; add header size ==> total packet size
				
				    cmp       eax, ecx                   ; fifo space avail >= packet size ?
				    jge       $win_tri_begin_D           ; yup, start writing triangle data
				
				    push      @Line                      ; line number inside this function
				    push      0h                         ; pointer to function name = NULL
				
				    push      ecx                        ; fifo space needed
				    call      __grCommandTransportMakeRoom@12 ; note: updates fifoPtr
				
				        align 32
				$win_tri_begin_D:
				
				    mov       eax, vertexCount           ; number of vertices in triangles
				    mov       fifo, [gc + fifoPtr]       ; get fifoPtr
				
				    mov       ebp, [gc + cullStripHdr]   ; <2:0> = type
				    shl       eax, 6                     ; <9:6> = vertex count (max 15)
				
				    or        eax, ebp                   ; setup mode, vertex count, and type
				    lea       dlpStart, [gc+tsuDataList] ; pointer to start of offset list
				
				    test      fifo, 4                    ; fifoPtr QWORD aligned ?
				    jz        $fifo_aligned_D            ; yup
				
				    mov       [fifo], eax                ; PCI write packet type
				    add       fifo, 4                    ; fifo pointer now QWORD aligned
				
				$win_vertex_loop_D_WB0:                  ; nothing in "write buffer"
				
				    mov       edx, [vertexPtr]           ; dereference pointer, edx points to vertex
				    add       vertexPtr, 4               ; next pointer
				
				    lea       dlp, [gc + tsuDataList]    ; get pointer to offset list
				    movq      mm1, [edx]                 ; get vertex x,y
				
				    mov       eax, [dlp]                 ; get first offset from offset list
				    add       dlp, 4                     ; dlp++
				
				    movq      [fifo], mm1                ; PCI write x, y
				    add       fifo, 8                    ; fifo += 2
				
				    test      eax, eax                   ; if offset == 0, end of offset list
				    je        $win_datalist_end_D_WB0    ; no more vertex data, nothing in "write buffer" 
				
				$win_datalist_loop_D_WB0:                ; nothing in "write buffer"
				
				    movd      mm1, [edx + eax]           ; get next parameter
				    mov       eax, [dlp]                 ; get next offset from offset list
				
				    test      eax, eax                   ; at end of offset list (offset == 0) ?
				    jz        $win_datalist_end_D_WB1    ; exit, write buffer contains one DWORD
				
				    movd      mm2, [edx + eax]           ; get next parameter
				    add       dlp, 8                     ; dlp++
				
				    mov       eax, [dlp-4]               ; get next offset from offset list
				    add       fifo, 8                    ; fifoPtr += 2*sizeof(FxU32)
				
				    punpckldq mm1, mm2                   ; current param | previous param
				    cmp       eax, 0                     ; at end of offset list (offset == 0) ?
				
				    movq      [fifo-8], mm1              ; PCI write current param | previous param
				    jnz       $win_datalist_loop_D_WB0   ; nope, copy next parameter
				
				$win_datalist_end_D_WB0:
				
				    dec       vertexCount                ; another vertex done. Any left?
				    jnz       $win_vertex_loop_D_WB0     ; yup, output next vertex
				
				$win_vertex_end_D_WB0:
				
				    mov       eax, [gc + fifoPtr]        ; old fifoPtr
				    nop                                  ; filler
				
				    mov       ebp, [gc + fifoRoom]       ; old number of bytes available in fifo
				    nop                                  ; filler
				
				    mov       vertexCount, [esp + _count]; remaining vertices before previous loop
				    sub       eax, fifo                  ; old fifoPtr - new fifoPtr (fifo room used)
				
				    add       ebp, eax                   ; new number of bytes available in fifo
				    mov       [gc + fifoPtr], fifo       ; save current fifoPtr 
				
				    sub       vertexCount, 15            ; remaining number of vertices to process
				
				    mov       [gc + fifoRoom], ebp       ; save current number of bytes available in fifo
				    test      vertexCount, vertexCount   ; any vertices left to process ?
				
				    mov       [esp + _count], vertexCount; remaining number of vertices to process
				    jg        $win_coords_loop_D         ; loop if number of vertices to process >= 0
				
				    femms                                ; no more MMX code; clear MMX/FPU state
				
				    pop       ebp                        ; restore frame pointer
				    pop       ebx                        ; restore caller's register variable
				
				    pop       esi                        ; restore caller's register variable
				    pop       edi                        ; restore caller's register variable
				
				    ret       12                         ; return, pop 3 DWORD parameters off stack
				
				$fifo_aligned_D:
				
				    movd      mm1, eax                   ; move header into "write buffer"
				
				$win_vertex_loop_D_WB1:                  ; one DWORD in "write buffer"
				
				    mov       edx, [vertexPtr]           ; dereference pointer, edx points to vertex
				    add       vertexPtr, 4               ; next pointer
				
				    add       fifo, 8                    ; fifoPtr += 2*sizeof(FxU32)
				    lea       dlp, [gc + tsuDataList]    ; get pointer to start of offset list
				
				    movd      mm2, [edx]                 ; 0 | x of vertex
				    add       dlp, 4                     ; dlp++
				 
				    mov       eax, [dlp-4]               ; first offset in offset list
				    punpckldq mm1, mm2                   ; packet header | x of vertex
				
				    movq      [fifo-8], mm1              ; PCI write packet header | x of vertex
				    movd      mm1, [edx + 4]             ; 0 | y of vertex
				
				    cmp       eax, 0                     ; offset == 0 (list empty) ?
				    je        $win_datalist_end_D_WB1    ; yup, no more vertex data, one DWORD in "write buffer"
				
				$win_datalist_loop_D_WB1:                ; one DWORD in "write buffer" = MM1
				
				    movd      mm2, [edx + eax]           ; get next parameter
				    add       fifo, 8                    ; fifoPtr += 2*sizeof(FxU32)
				
				    mov       eax, [dlp]                 ; get next offset from offset list
				    add       dlp, 8                     ; dlp += 2
				
				    punpckldq mm1, mm2                   ; current param | previous param
				    test      eax, eax                   ; at end of offset list (offset == 0) ?
				
				    movq      [fifo-8], mm1              ; PCI write current param | previous param
				    jz        $win_datalist_end_D_WB0    ; yes, exit, "write buffer" empty
				
				    movd      mm1, [edx + eax]           ; get next parameter
				    mov       eax, [dlp-4]               ; get next offset from offset list
				
				    test      eax,  eax                  ; at end of offset list (offset == 0) ?
				    jnz       $win_datalist_loop_D_WB1   ; nope, copy next parameter
				
				$win_datalist_end_D_WB1:
				
				    dec       vertexCount                ; another vertex done. Any left?
				    jnz       $win_vertex_loop_D_WB1     ; yup, output next vertex
				
				$win_vertex_end_D_WB1:
				
				    movd      [fifo], mm1                ; flush "write buffer"
				    mov       eax, [gc + fifoPtr]        ; old fifoPtr
				
				    add       fifo, 4                    ; fifoPtr++
				    mov       ebp, [gc + fifoRoom]       ; old number of bytes available in fifo
				
				    mov       vertexCount, [esp + _count]; remaining vertices before previous loop
				    sub       eax, fifo                  ; old fifoPtr - new fifoPtr (fifo room used)
				
				    mov       [gc + fifoPtr], fifo       ; save current fifoPtr 
				    sub       vertexCount, 15            ; remaining number of vertices to process
				
				    add       ebp, eax                   ; new number of bytes available in fifo
				    mov       [gc + fifoRoom], ebp       ; save current number of bytes available in fifo
				
				    mov       [esp + _count], vertexCount; remaining number of vertices to process 
				    cmp       vertexCount, 0             ; any vertices left to process ?
				
				    nop                                  ; filler
				    jg        $win_coords_loop_D         ; loop if number of vertices to process >= 0
				
				    femms                                ; no more MMX code; clear MMX/FPU state
				
				    pop       ebp                        ; restore frame pointer
				    pop       ebx                        ; restore caller's register variable
				
				    pop       esi                        ; restore caller's register variable
				    pop       edi                        ; restore caller's register variable
				
				    ret       12                         ; return, pop 3 DWORD parameters off stack
				
				    ALIGN     32
				
				; 989  :   }
				; 990  :   else {
				; 991  :     /*
				; 992  :      * first cut of clip space coordinate code, no optimization.
				; 993  :      */
				; 994  :     float oow;
				; 995  :     
				; 996  :     while (count > 0) {
				; 997  :       FxI32 vcount = count >= 15 ? 15 : count;
				; 998  :       
				; 999  :       GR_SET_EXPECTED_SIZE(vcount * gc->state.vData.vSize, 1);
				; 1000 :       TRI_STRIP_BEGIN(kSetupStrip, vcount, gc->state.vData.vSize, SSTCP_PKT3_BDDBDD);
				; 1001 :       
				; 1002 :       for (k = 0; k < vcount; k++) {
				; 1003 :         vPtr = pointers;
				; 1004 :         if (mode)
				; 1005 :           vPtr = *(float **)pointers;
				; 1006 :         oow = 1.0f / FARRAY(vPtr, gc->state.vData.wInfo.offset);
				; 1007 :         
				; 1008 :         /* x, y */
				; 1009 :         TRI_SETF(FARRAY(vPtr, 0)
				; 1010 :                  *oow*gc->state.Viewport.hwidth + gc->state.Viewport.ox);
				; 1011 :         TRI_SETF(FARRAY(vPtr, 4)
				; 1012 :                  *oow*gc->state.Viewport.hheight + gc->state.Viewport.oy);
				; 1013 :         (float *)pointers += stride;
				; 1014 :         
				; 1015 :         TRI_VP_SETFS(vPtr,oow);
				; 1016 :       }
				; 1017 :       TRI_END;
				; 1018 :       GR_CHECK_SIZE();
				; 1019 :       count -= 15;
				; 1020 :   }
				; 1021 : }
				
				$clip_coordinates_D:
				
				    mov       [strideinbytes], 4         ; unit stride for array of pointers to vertices
				
				$clip_coordinates_ND:
				
				dataElem      textequ <ebp>              ; number of vertex components processed
				
				    movd      mm6,[__GlideRoot+pool_f255]; GlideRoot.pool.f255 
				
				$clip_coords_begin:
				
				    sub       vertexCount, 15            ; vertexCount >= 15 ? CF=0 : CF=1
				    mov       ecx, [gc + vertexSize]     ; bytes of data for each vertex 
				
				    sbb       eax, eax                   ; vertexCount >= 15 ? 00000000:ffffffff
				
				    and       vertexCount, eax           ; vertexCount >= 15 ? 0 : vertexcount-15
				    add       vertexCount, 15            ; vertexcount >= 15 ? 15 :vertexcount
				
				    imul      ecx, vertexCount           ; total amount of vertex data we'll send
				
				    mov       eax, [gc + fifoRoom]       ; fifo space available
				    add       ecx, 4                     ; add header size ==> total packet size
				
				    cmp       eax, ecx                   ; fifo space avail >= packet size ?
				    jge       $clip_tri_begin            ; yup, start writing triangle data
				
				    push      @Line                      ; line number inside this function
				    push      0h                         ; pointer to function name = NULL
				
				    push      ecx                        ; fifo space needed
				    call      __grCommandTransportMakeRoom@12 ; note: updates fifoPtr
				
				        align 32
				$clip_tri_begin:
				    mov       edx, vertexCount           ; number of vertices in triangles
				    mov       fifo, [gc + fifoPtr]       ; get fifoPtr
				
				    mov       ebp, [gc + cullStripHdr]   ; <2:0> = type
				    shl       edx, 6                     ; <9:6> = vertex count (max 15)
				
				    or        edx, ebp                   ; setup mode, vertex count, and type
				
				    mov       [fifo], edx                ; PCI write packet type
				    add       fifo, 4                    ; fifo pointer now QWORD aligned
				
				$clip_for_begin:
				
				    mov       edx, vertexPtr             ; vertex = vertexPtr (assume no-deref mode)
				    mov       eax, [esp+_mode]           ; mode 0 = no deref, mode 1 = deref
				
				    mov       [vertices], vertexCount    ; save numnber of vertices
				    test      eax, eax                   ; deref mode ?
				
				    mov       eax, [gc + wInfo_offset]   ; get offset of W into vertex struct
				    jz        $clip_noderef              ; yup, no-deref mode
				
				    mov       edx, [vertexPtr]           ; vertex = *vertexPtr
				
				$clip_noderef:
				
				    movd      mm0, [edx + eax]           ; 0 | W of current vertex
				    pfrcp     mm1, mm0                   ; 0 | 1/W approx
				
				    mov       ebp, [strideinbytes]       ; offset to next vertex/vertexPtr
				    movq      mm2, [edx]                 ; y | x of current vertex
				
				    pfrcpit1  mm0, mm1                   ; 0 | 1/W refine
				    movq      mm3, [gc + vp_hwidth]      ; gc->state.Viewport.hheight | gc->state.Viewport.hwidth
				
				    movq      mm4, [gc + vp_ox]          ; gc->state.Viewport.oy | gc->state.Viewport.ox
				    add       vertexPtr, ebp             ; point to next vertex/VertexPtr
				
				    pfrcpit2  mm0, mm1                   ; oow = 1.0f / FARRAY(vPtr, gc->state.vData.wInfo.offset
				    mov       esi, [gc + paramIndex]     ; gc->state.paramIndex
				
				    pfmul     mm2, mm3                   ; TRI_SETF(FARRAY(vPtr,0)*state.Viewport.hheight | TRI_SETF(FARRAY(vPtr,4)*state.Viewport.hwidth
				    xor       dataElem, dataElem         ; dataElem = 0
				
				    add       fifo, 8                    ; fifoPtr += 2*sizeof(FxFloat)
				    punpckldq mm0, mm0                   ; oow | oow
				
				    pfmul     mm2, mm0                   ; TRI_SETF(FARRAY(vPtr, 4)*oow*gc->state.Viewport.height | TRI_SETF(FARRAY(vPtr, 0)*oow*gc->state.Viewport.hwidth
				    pfadd     mm2, mm4                   ; TRI_SETF(FARRAY(vPtr, 4)*oow*gc->state.Viewport.hheight + gc->state.Viewport.oy) |
				
				;;;  FxI32 i, dataElem=0; \
				;;;  i = gc->tsuDataList[dataElem]; \
				;;;  if (gc->state.paramIndex & (STATE_REQUIRES_IT_DRGB | STATE_REQUIRES_IT_ALPHA)) { \
				;;;    if (gc->state.vData.colorType == GR_FLOAT) { \
				;;;      if (gc->state.paramIndex & STATE_REQUIRES_IT_DRGB) { \
				;;;        DA_SETF_SCALE_ADVANCE(_s,_GlideRoot.pool.f255); \
				;;;        DA_SETF_SCALE_ADVANCE(_s,_GlideRoot.pool.f255); \
				;;;        DA_SETF_SCALE_ADVANCE(_s,_GlideRoot.pool.f255); \
				;;;      } \
				;;;      if (gc->state.paramIndex & STATE_REQUIRES_IT_ALPHA) { \
				;;;        DA_SETF_SCALE_ADVANCE(_s,_GlideRoot.pool.f255); \
				;;;      } \
				;;;    } \
				;;;    else { \
				;;;      DA_SETF(FARRAY(_s, i)); \
				;;;      dataElem++; \
				;;;      i = gc->tsuDataList[dataElem]; \
				;;;    } \
				;;;  } \
				
				    test      esi, 3                     ; STATE_REQUIRES_IT_DRGB | STATE_REQUIRES_IT_ALPHA ?
				    mov       eax, [gc + tsuDataList]    ; first entry from offset list
				
				    movq      [fifo-8], mm2              ; PCI write transformed x, y
				    jz        $clip_setup_ooz            ; nope, no color at all needed
				  
				    cmp       DWORD PTR [gc+colorType], 0; gc->state.vData.colorType == GR_FLOAT ?
				    jne       $clip_setup_pargb          ; nope, packed ARGB format
				  
				    test      esi, 1                     ; STATE_REQUIRES_IT_DRGB ?
				    jz        $clip_setup_a              ; no, but definitely A
				
				    movd      mm2, [edx + eax]           ; 0 | r
				    mov       eax, [gc + tsuDataList+4]  ; offset of g part of vertex data
				
				    pfmul     mm2, mm6                   ; 0 | r * 255.0f
				    movd      mm3, [edx + eax]           ; 0 | g
				
				    mov       eax, [gc + tsuDataList + 8]; offset of b part of vertex data
				    movd      [fifo], mm2                ; PCI write r*255
				
				    pfmul     mm3, mm6                   ; 0 | g * 255.0f
				    movd      mm2, [edx + eax]           ; 0 | b
				
				    movd      [fifo+4], mm3              ; PCI write g*255
				    mov       dataElem, 12               ; dataElem = 3
				
				    pfmul     mm2, mm6                   ; 0 | b * 255.0f
				    mov       eax, [gc + tsuDataList+12] ; offset of A part of vertex data
				
				    test      esi, 2                     ; STATE_REQUIRES_IT_ALPHA ?
				    lea       fifo, [fifo+12]            ; fifoPtr += 3*sizeof(FxFloat)
				
				    movd      [fifo-4], mm2              ; PCI write b*255
				    jz        $clip_setup_ooz            ; nope, no alpha, proceeed with ooz
				
				$clip_setup_a:
				    movd      mm2, [eax+edx]             ; 0 | a
				    add       fifo, 4                    ; fifoPtr += sizeof(FxFloat)
				
				    mov       esp, esp                   ; filler
				    add       dataElem, 4                ; dataElem++ 
				
				    pfmul     mm2, mm6                   ; 0 | a * 255.0f
				    mov       eax, [gc+dataElem+tsuDataList]; offset of next part of vertex data
				
				    movd      [fifo-4], mm2              ; PCI write a*255
				    jmp       $clip_setup_ooz            ; check whether we need to push out z
				
				$clip_setup_pargb:
				    movd      mm2, [eax+edx]             ; get packed ARGB data
				    add       fifo, 4                    ; fifoPtr += sizeof(FxU32)
				
				    mov       dataElem, 4                ; dataElem = 1 (namely pargb)
				    mov       eax, [gc+tsuDataList+4]    ; offset of next part of vertex data
				
				    movd      [fifo-4], mm2              ; PCI write packed ARGB
				
				;;;  if (gc->state.paramIndex & STATE_REQUIRES_OOZ) { \
				;;;    if (gc->state.fbi_config.fbzMode & SST_DEPTH_FLOAT_SEL) { \
				;;;      if (gc->state.vData.qInfo.mode == GR_PARAM_ENABLE) { \
				;;;        DA_SETF(FARRAY(_s, gc->state.vData.qInfo.offset)*_oow); \
				;;;      } else { \
				;;;        DA_SETF(_oow); \
				;;;      } \
				;;;      dataElem++; \
				;;;      i = gc->tsuDataList[dataElem]; \
				;;;    } \
				;;;    else { \
				;;;      DA_SETF(FARRAY(_s, i)*_oow*gc->state.Viewport.hdepth + gc->state.Viewport.oz); \
				;;;      dataElem++; \
				;;;      i = gc->tsuDataList[dataElem]; \
				;;;    } \
				;;;  } \
				
				$clip_setup_ooz:
				  
				    test      esi, 4                     ; STATE_REQUIRES_OOZ ?
				    jz        $clip_setup_qow            ; nope
				
				    test      DWORD PTR[gc+fbi_fbzMode],200000h ; gc->state.fbi_config.fbzMode & SST_DEPTH_FLOAT_SEL != 0 ?
				    je        $clip_setup_ooz_nofog      ; nope
				
				    cmp       DWORD PTR[gc+qInfo_mode], 0; gc->state.vData.qInfo.mode == GR_PARAM_ENABLE ?
				    jz        $clip_setup_fog_oow        ; nope
				
				    mov       eax, [gc + qInfo_offset]   ; offset of Q component of vertex
				    add       fifo, 4                    ; fifoPtr += sizeof(FxFloat)
				
				    add       dataElem, 4                ; dataElem++
				    movd      mm2, [edx + eax]           ; 0 | q of vertex
				
				    mov       eax,[gc+dataElem+tsuDataList]; pointer to next vertex component
				    pfmul     mm2, mm0                   ; 0 | q*oow
				
				    movd      [fifo-4], mm2              ; PCI write transformed Q
				    jmp       $clip_setup_qow            ; check whether we need to write Q or W
				
				$clip_setup_fog_oow:
				
				    add       fifo, 4                    ; fifoPtr += sizeof(FxFloat) 
				    add       dataElem, 4                ; dataElem++
				
				    movd      mm3, [gc + depth_range]    ;
				    pfmul     mm3, mm0                   ; 
				
				    movd      mm4, [gc + depth_range]    ; depth range
				    pfsub     mm4, mm3                   ; 
				
				    movd      [fifo-4], mm4              ; PCI write oow
				    mov       eax,[gc+dataElem+tsuDataList]; pointer to next vertex component
				
				    jmp       $clip_setup_qow            ; check whether we need to write Q or W
				
				$clip_setup_ooz_nofog:
				
				    movd      mm2, [eax + edx]           ; 0 | z component of vertex
				    add       fifo, 4                    ; fifoPtr += sizeof(FxFloat)
				
				    add       dataElem, 4                ; dataElem += 1
				    movd      mm3, [gc + vp_hdepth]      ; 0 | gc->state.Viewport.hdepth
				
				    pfmul     mm2, mm0                   ; TRI_SETF(FARRAY(_s, i)*_oow
				    movd      mm4, [gc + vp_oz]          ; 0 | gc->state.Viewport.oz
				
				    pfmul     mm2, mm3                   ; 0 | TRI_SETF(FARRAY(_s, i)*_oow*gc->state.Viewport.hdepth
				    mov       eax, [gc+dataElem+tsuDataList]; offset of next vertex component
				
				    pfadd     mm2, mm4                   ; 0 | TRI_SETF(FARRAY(_s, i)*_oow*gc->state.Viewport.hdepth+gc->state.Viewport.oz
				    movd      [fifo-4], mm2              ; PCI write transformed Z
				
				;;;  if (gc->state.paramIndex & STATE_REQUIRES_OOW_FBI) { \
				;;;    if (gc->state.vData.fogInfo.mode == GR_PARAM_ENABLE) { \
				;;;      DA_SETF(FARRAY(_s, gc->state.vData.fogInfo.offset)*_oow); \
				;;;    } \
				;;;    else if (gc->state.vData.qInfo.mode == GR_PARAM_ENABLE) { \
				;;;      DA_SETF(FARRAY(_s, gc->state.vData.qInfo.offset)*_oow); \
				;;;    } else { \
				;;;      DA_SETF(_oow); \
				;;;    } \
				;;;    dataElem++; \
				;;;    i = gc->tsuDataList[dataElem]; \
				;;;  } \
				
				$clip_setup_qow:
				    test      esi, 8                     ; STATE_REQUIRES_OOW_FBI ?
				    jz        $clip_setup_qow0           ; nope
				
				    cmp       DWORD PTR[gc+fogInfo_mode],0; gc->state.vData.fogInfo.mode == GR_PARAM_ENABLE ?
				    jz        $clip_setup_oow_nofog      ; nope, no fog
				
				    mov       eax, [gc + fogInfo_offset] ; offset of fogInfo component of vertex
				    add       fifo, 4                    ; fifoPtr += sizeof(FxFloat)
				
				    add       dataElem, 4                ; dataElem++
				    movd      mm2, [edx + eax]           ; 0 | fogInfo of vertex
				
				    mov       eax,[gc+dataElem+tsuDataList]; pointer to next vertex component
				    pfmul     mm2, mm0                   ; fogInfo*oow
				
				    movd      [fifo-4], mm2              ; PCI write transformed Q
				    jmp       $clip_setup_qow0           ; continue with q0
				
				$clip_setup_oow_nofog:
				
				    cmp       DWORD PTR [gc+qInfo_mode],0; gc->state.vData.qInfo.mode == GR_PARAM_ENABLE ?
				    je        $clip_setup_oow            ; nope, write oow, not Q
				
				    mov       eax, [gc + qInfo_offset]   ; offset of Q component of vertex
				    add       fifo, 4                    ; fifoPtr += sizeof(FxFloat)
				
				    add       dataElem, 4                ; dataElem++
				    movd      mm2, [edx + eax]           ; 0 | q of vertex
				
				    mov       eax,[gc+dataElem+tsuDataList]; pointer to next vertex component
				    pfmul     mm2, mm0                   ; q*oow
				
				    movd      [fifo-4], mm2              ; PCI write transformed Q
				    jmp       $clip_setup_qow0           ; continue with q0
				
				$clip_setup_oow:
				    add       fifo, 4                    ; fifoPtr += sizeof(FxFloat) 
				    add       dataElem, 4                ; dataElem++
				
				    movd      [fifo-4], mm0              ; PCI write oow
				    mov       eax,[gc+dataElem+tsuDataList]; pointer to next vertex component
				
				;;;  if (gc->state.paramIndex & STATE_REQUIRES_W_TMU0) { \
				;;;    if (gc->state.vData.q0Info.mode == GR_PARAM_ENABLE) { \
				;;;      DA_SETF(FARRAY(_s, gc->state.vData.q0Info.offset)*_oow); \
				;;;    } \
				;;;    else { \
				;;;      DA_SETF(_oow); \
				;;;    } \
				;;;    dataElem++; \
				;;;    i = gc->tsuDataList[dataElem]; \
				;;;  } \
				
				$clip_setup_qow0:
				    test      esi, 16                    ; STATE_REQUIRES_W_TMU0 ?
				    jz        $clip_setup_stow0          ; nope 
				
				    cmp       DWORD PTR [gc+q0Info_mode],0; does vertex have Q component ?
				    je        $clip_setup_oow0           ; nope, not Q but W
				
				    mov       eax, [gc+q0Info_offset]    ; offset of Q component of vertex
				    add       fifo, 4                    ; fifoPtr += sizeof(FxFloat)
				
				    add       dataElem, 4                ; dataElem++
				    movd      mm2, [edx+eax]             ; 0 | q0 of vertex
				
				    mov       eax,[gc+dataElem+tsuDataList]; pointer to next vertex component
				    pfmul     mm2, mm0                   ; q0*oow
				
				    movd      [fifo-4], mm2              ; PCI write transformed q0
				    jmp       $clip_setup_stow0          ; continue with stow0
				
				    nop                                  ; filler
				
				$clip_setup_oow0:
				    add       fifo, 4                    ; fifoPtr += sizeof(FxFloat) 
				    add       dataElem, 4                ; dataElem++
				
				    movd      [fifo-4], mm0              ; PCI write oow
				    mov       eax,[gc+dataElem+tsuDataList]; pointer to next vertex component
				
				;;;  if (gc->state.paramIndex & STATE_REQUIRES_ST_TMU0) { \
				;;;    DA_SETF_SCALE_ADVANCE(_s,_oow*gc->state.tmu_config[0].s_scale); \
				;;;    DA_SETF_SCALE_ADVANCE(_s,_oow*gc->state.tmu_config[0].t_scale); \
				;;;  } \
				
				$clip_setup_stow0:
				
				    test      esi, 32                    ; STATE_REQUIRES_ST_TMU0 ?
				    jz        $clip_setup_qow1           ; nope
				
				    movq      mm7, [gc + tmu0_s_scale]   ; state.tmu_config[0].t_scale | state.tmu_config[0].s_scale
				    add       fifo, 8                    ; fifoPtr += 2*sizeof(FxFloat)
				
				    movd      mm2, [edx + eax]           ; param1
				    mov       eax,[gc+dataElem+tsuDataList+4];pointer to next vertex component
				
				    pfmul     mm7, mm0                   ; oow*tmu0_t_scale | oow*tmu0_s_scale
				    add       dataElem, 8                ; dataElem += 2
				
				    movd      mm3, [edx + eax]           ; param2
				    punpckldq mm2, mm3                   ; param2 | param1
				
				    pfmul     mm2, mm7                   ; param2*oow*tmu0_t_scale | param1*oow*tmu0_s_scale
				    nop                                  ; filler
				
				    movq      [fifo-8], mm2              ; PCI write param2*oow*tmu0_t_scale | param1*oow*tmu0_s_scale
				    mov       eax, [gc+dataElem+tsuDataList]; pointer to next vertex component
				
				;;;  if (gc->state.paramIndex & STATE_REQUIRES_W_TMU1) { \
				;;;    if (gc->state.vData.q1Info.mode == GR_PARAM_ENABLE) { \
				;;;      DA_SETF(FARRAY(_s, gc->state.vData.q1Info.offset)*_oow); \
				;;;    } \
				;;;    else { \
				;;;      DA_SETF(_oow); \
				;;;    } \
				;;;    dataElem++; \
				;;;    i = gc->tsuDataList[dataElem]; \
				;;;  } \
				
				$clip_setup_qow1:
				    test      esi, 64                    ; STATE_REQUIRES_W_TMU1 ?
				    jz        $clip_setup_stow1          ; nope
				
				    cmp       DWORD PTR [gc+q1Info_mode],0; does vertex have Q component ?
				    je        $clip_setup_oow1           ; nope, not Q but W
				
				    mov       eax, [gc+q1Info_offset]    ; offset of Q component of vertex
				    add       fifo, 4                    ; fifoPtr += sizeof(FxFloat)
				
				    add       dataElem, 4                ; dataElem++
				    movd      mm2, [edx + eax]           ; 0 | q1 of vertex
				
				    mov       eax,[gc+dataElem+tsuDataList]; pointer to next vertex component
				    pfmul     mm2, mm0                  ; q1*oow
				
				    movd      [fifo-4], mm2              ; PCI write transformed q1
				    jmp       $clip_setup_stow1          ; continue with stow1
				
				$clip_setup_oow1:
				    add       fifo, 4                    ; fifoPtr += sizeof(FxFloat) 
				    add       dataElem, 4                ; dataElem++
				
				    movd      [fifo-4], mm0              ; PCI write oow
				    mov       eax,[gc+dataElem+tsuDataList]; pointer to next vertex component
				
				;;;  if (gc->state.paramIndex & STATE_REQUIRES_ST_TMU1) { \
				;;;    DA_SETF_SCALE_ADVANCE(_s,_oow*gc->state.tmu_config[1].s_scale); \
				;;;    DA_SETF_SCALE_ADVANCE(_s,_oow*gc->state.tmu_config[1].t_scale); \
				;;;  } \
				
				$clip_setup_stow1:
				
				    test      esi, 128                   ; STATE_REQUIRES_ST_TMU1 ?
				    mov       vertexCount, [vertices]    ; get number of vertices
				
				    movq      mm7, [gc + tmu1_s_scale]   ; state.tmu_config[1].t_scale | state.tmu_config[1].s_scale
				    jz        $clip_setup_end            ; nope
				
				    movd      mm2, [edx + eax]           ; param1
				    add       fifo, 8                    ; fifoPtr += 2*sizeof(FxFloat)
				
				    mov       eax,[gc+dataElem+tsuDataList+4]; pointer to next vertex component
				    pfmul     mm7, mm0                   ; oow*state.tmu_config[1].t_scale | oow*state.tmu_config[1].s_scale
				
				    movd      mm3, [edx + eax]           ; param2
				    punpckldq mm2, mm3                   ; param2 | param1
				
				    pfmul     mm2, mm7                   ; param2*oow*state.tmu_config[1].t_scale | param1*oow*state.tmu_config[1].s_scale
				    movq      [fifo-8], mm2              ; PCI write param2*oow*state.tmu_config[1].t_scale | param1*oow*state.tmu_config[1].s_scale
				
				$clip_setup_end:
				
				    dec       vertexCount                ; vcount--
				    jnz       $clip_for_begin            ; until 
				
				$clip_for_end:
				
				    mov       eax, [gc + fifoPtr]        ; old fifoPtr
				    mov       ebp, [gc + fifoRoom]       ; old number of bytes available in fifo
				
				    mov       vertexCount, [esp + _count]; remaining vertices before previous loop
				    sub       eax, fifo                  ; old fifoPtr - new fifoPtr (fifo room used)
				
				    mov       [gc + fifoPtr], fifo       ; save current fifoPtr 
				    add       ebp, eax                   ; new number of bytes available in fifo
				
				    sub       vertexCount, 15            ; remaining number of vertices to process
				    mov       [gc + fifoRoom], ebp       ; save current number of bytes available in fifo
				
				    mov       [esp + _count], vertexCount; remaining number of vertices to process 
				    cmp       vertexCount, 0             ; any vertices left to process ?
				
				    jg        $clip_coords_begin         ; loop if number of vertices to process >= 0
				
				    femms                                ; no more MMX code; clear MMX/FPU state
				
				$tris_done:
				    pop       ebp                        ; restore frame pointer
				    pop       ebx                        ; restore caller's register variable
				
				    pop       esi                        ; restore caller's register variable
				    pop       edi                        ; restore caller's register variable
				
				    ret       12                         ; return, pop 3 DWORD parameters
				__grDrawTriangles_3DNow@12 ENDP
				
				_pktype   = 20
				_type     = 24
				_mode     = 28
				_count    = 32
				_pointers = 36
				
				gc            TEXTEQU  <edi>             ; points to graphics context
				fifo          TEXTEQU  <ecx>             ; points to next entry in fifo
				dlp           TEXTEQU  <ebp>             ; points to dataList structure
				vertexCount   TEXTEQU  <esi>             ; Current vertex counter in the packet
				vertexPtr     TEXTEQU  <ebx>             ; Current vertex pointer (in deref mode)
				vertex        TEXTEQU  <ebx>             ; Current vertex (in non-deref mode)
				dlpStart      TEXTEQU  <edx>             ; Pointer to start of offset list
				
				X TEXTEQU     <0>
				Y TEXTEQU     <4>
				
				                  ALIGN  32
				
				    PUBLIC  __grDrawVertexList_3DNow_Window@20
				__grDrawVertexList_3DNow_Window@20 PROC NEAR
				; 132  : {
				
				    mov       edx, DWORD PTR fs:[18h]    ; get thread local storage base pointer        
				    push      edi                        ; save caller's register variable
				
				    push      esi                        ; save caller's register variable
				    mov       vertexCount, [esp+_count-8]; number of vertices in strip/fan
				
				    push      ebp                        ; save frame pointer
				    mov       ebp, [__GlideRoot + tlsOffset]; GC position relative to tls base    
				
				    push      ebx                        ; save caller's register variable        
				    mov       vertexPtr, [esp+_pointers] ; get current vertex pointer (deref mode)
				                                         ; get current vertex (non-deref mode)
				    
				    mov       gc, [edx + ebp]            ; get current graphics context from tls
				    test      vertexCount, vertexCount   ; number of vertices <= 0 ?
				
				    nop                                  ; filler
				    jle       strip_done                 ; yup, the strip/fan is done
				  
				;;;     vSize = gc->state.vData.vSize
				;;;     if (stride == 0)
				;;;       stride = gc->state.vData.vStride;
				
				;; We can operate in one of two modes:
				;;
				;; 0. We are stepping through an array of vertices, in which case
				;; the stridesize is equal to the size of the vertex data, and
				;; always > 4, since vertex data must a least contain x,y (ie 8 bytes).
				;; vertexPtr is pointing to the array of vertices.
				;;
				;; 1. We are stepping through an array of pointers to vertices
				;; in which case the stride is 4 bytes and we need to dereference
				;; the pointers to get at the vertex data. vertexPtr is pointing
				;; to the array of pointers to vertices.
				
				    mov       edx, [esp + _mode]         ; get mode (0 or 1)
				    mov       eax, [gc + vertexSize]     ; size of vertex data in bytes
				
				    test      edx, edx                   ; mode 0 (array of vertices) ?
				    mov       edx, [gc + vertexStride]   ; get stride in DWORDs
				    
				    jnz       deref_mode                 ; nope, it's mode 1 (array of pointers to vertices)
				
				    femms                                ; we'll use MMX; clear MMX/3DX state      
				
				    shl       edx, 2                     ; stride in bytes
				    mov       [strideinbytes], edx       ; save off stride (in bytes)
				
				;;;     Draw the first (or possibly only) set.  This is necessary because
				;;;     the packet is 3_BDDDDDD, and in the next set, the packet is 3_DDDDDD
				;;;     We try to make tstrip code simple to read. We combine the original code
				;;;     into a single loop by adding an extra packet type assignment at the end of the loop.
				;;; 
				;;;     if (gc->state.grCoordinateSpaceArgs.coordinate_space_mode == GR_WINDOW_COORDS) {
				;;;       while (count > 0) {
				;;;         FxI32 k, vcount = count >= 15 ? 15 : count;
				;;;         GR_SET_EXPECTED_SIZE(vcount * vSize, 1);
				;;;         TRI_STRIP_BEGIN(type, vcount, vSize, pktype);
				
				
				win_coords_loop_ND:
				
				    sub       vertexCount, 15            ; vertexCount >= 15 ? CF=0 : CF=1
				    mov       ecx, [gc + vertexSize]     ; bytes of data for each vertex 
				
				    sbb       eax, eax                   ; vertexCount >= 15 ? 00000000:ffffffff
				
				    and       vertexCount, eax           ; vertexCount >= 15 ? 0 : vertexcount-15
				    add       vertexCount, 15            ; vertexcount >= 15 ? 15 :vertexcount
				
				    imul      ecx, vertexCount           ; total amount of vertex data we'll send
				
				    mov       eax, [gc + fifoRoom]       ; fifo space available
				    add       ecx, 4                     ; add header size ==> total packet size
				
				    cmp       eax, ecx                   ; fifo space avail >= packet size ?
				    jge       win_strip_begin_ND         ; yup, start writing strip data
				
				    push      @Line                      ; line number inside this function
				    push      0h                         ; pointer to function name = NULL
				
				    push      ecx                        ; fifo space needed
				    call      __grCommandTransportMakeRoom@12 ; note: updates fifoPtr
				
				        align 32
				win_strip_begin_ND:
				;;;     Setup packet header
				;;;
				    mov       eax, vertexCount           ; number of vertices in strip/fan
				    mov       edx, [esp + _type]         ; setup mode
				
				    mov       fifo, [gc + fifoPtr]       ; get fifoPtr
				    shl       edx, 22                    ; <27:22> = setup mode (kSetupStrip or kSetupFan)
				
				    mov       ebp, [gc + cullStripHdr]   ; <2:0> = type
				    shl       eax, 6                     ; <9:6> = vertex count (max 15)
				
				    or        eax, edx                   ; setup mode and vertex count
				    mov       edx, [esp + _pktype]       ; <5:3> = command (SSTCP_PKT3_BDDBDD, SSTCP_PKT3_BDDDDD, or SSTCP_PKT3_DDDDDD)
				
				    or        eax, ebp                   ; setup mode, vertex count, and type
				    nop                                  ; filler
				
				    or        eax, edx                   ; setup mode, vertex count, type, and command
				    lea       dlpStart, [gc+tsuDataList] ; pointer to start of offset list
				
				    test      fifo, 4                    ; fifoPtr QWORD aligned ?
				    jz        fifo_aligned_ND            ; yup
				
				    mov       [fifo], eax                ; PCI write packet type
				    add       fifo, 4                    ; fifo pointer now QWORD aligned
				
				;;;     for (k = 0; k < vcount; k++) {
				;;;       FxI32 i;
				;;;       FxU32 dataElem;
				;;;       float *vPtr;
				;;;       vPtr = pointers;
				;;;       if (mode)
				;;;         vPtr = *(float **)vPtr
				;;;       (float *)pointers += stride;
				;;;       TRI_SETF(FARRAY(vPtr, 0));
				;;;       dataElem = 0;
				;;;       TRI_SETF(FARRAY(vPtr, 4));
				;;;       i = gc->tsuDataList[dataElem];
				
				win_vertex_loop_ND_WB0:                  ; nothing in "write buffer"
				
				    mov       eax, [dlpStart]            ; get first offset from offset list
				    lea       dlp, [dlpStart+4]          ; point to start of offset list
				
				    movq      mm1, [vertex+X]            ; get vertex x,y
				    add       fifo, 8                    ; fifoPtr += 2*sizeof(FxU32)
				
				    nop                                  ; filler
				    test      eax, eax                   ; if offset == 0, end of list
				
				    movq      [fifo-8], mm1              ; PCI write x, y
				    jz        win_datalist_end_ND_WB0    ; no more vertex data, nothing in "write buffer" 
				
				;;;       while (i != GR_DLIST_END) {
				;;;         TRI_SETF(FARRAY(vPtr, i));
				;;;         dataElem++;
				;;;         i = gc->tsuDataList[dataElem];
				;;;       }
				
				win_datalist_loop_ND_WB0:                ; nothing in "write buffer"
				
				    movd      mm1, [vertex + eax]        ; get next parameter
				    mov       eax, [dlp]                 ; get next offset from offset list
				
				    test      eax, eax                   ; at end of offset list (offset == 0) ?
				    jz        win_datalist_end_ND_WB1    ; exit, write buffer contains one DWORD
				
				    movd      mm2, [vertex + eax]        ; get next parameter
				    add       dlp, 8                     ; dlp++
				
				    mov       eax, [dlp-4]               ; get next offset from offset list
				    add       fifo, 8                    ; fifoPtr += 2*sizeof(FxU32)
				
				    test      eax, eax                   ; at end of offset list (offset == 0) ?
				    punpckldq mm1, mm2                   ; current param | previous param
				
				    movq      [fifo-8], mm1              ; PCI write current param | previous param
				    jnz       win_datalist_loop_ND_WB0   ; nope, copy next parameter
				
				win_datalist_end_ND_WB0:
				
				    mov       eax, [strideinbytes]       ; get offset to next vertex
				    sub       vertexCount, 1             ; another vertex done. Any left?
				
				    lea       vertex, [vertex + eax]     ; points to next vertex
				    jnz       win_vertex_loop_ND_WB0     ; yup, output next vertex
				
				win_vertex_end_ND_WB0:
				
				;;;       TRI_END;
				;;;     Prepare for the next packet (if the strip size is longer than 15)
				;;;       GR_CHECK_SIZE();
				;;;       count -= 15;
				;;;       pktype = SSTCP_PKT3_DDDDDD;
				;;;     }
				  
				    mov       ebp, 16                    ; pktype = SSTCP_PKT3_DDDDDD (strip continuation)
				    mov       eax, [gc + fifoPtr]        ; old fifoPtr
				
				    mov       [esp + _pktype], ebp       ; pktype = SSTCP_PKT3_DDDDDD (strip continuation)
				    mov       ebp, [gc + fifoRoom]       ; old number of bytes available in fifo
				
				    mov       vertexCount, [esp + _count]; remaining vertices before previous loop
				    sub       eax, fifo                  ; old fifoPtr - new fifoPtr (fifo room used)
				
				    mov       [gc + fifoPtr], fifo       ; save current fifoPtr 
				    add       ebp, eax                   ; new number of bytes available in fifo
				
				    nop                                  ; filler
				    sub       vertexCount, 15            ; remaining number of vertices to process
				
				    mov       [gc + fifoRoom], ebp       ; save current number of bytes available in fifo
				    mov       [esp + _count], vertexCount; remaining number of vertices to process 
				
				    test      vertexCount, vertexCount   ; any vertices left to process ?
				    jg        win_coords_loop_ND         ; loop if number of vertices to process >= 0
				
				    femms                                ; no more MMX code; clear MMX/FPU state
				
				    pop       ebx                        ; restore caller's register variable
				    pop       ebp                        ; restore frame pointer
				
				    pop       esi                        ; restore caller's register variable
				    pop       edi                        ; restire caller's register variable
				
				    ret       20                         ; return, pop 5 DWORD parameters off stack
				
				    ALIGN 32
				
				fifo_aligned_ND:
				
				    movd      mm1, eax                   ; move header into "write buffer"
				
				win_vertex_loop_ND_WB1:                  ; one DWORD in "write buffer"
				
				    movd      mm2, [vertex + X]          ; 0 | x of vertex
				    add       fifo, 8                    ; fifoPtr += 2*sizeof(FxU32)
				
				    lea       dlp, [dlpStart + 4]        ; point to start of offset list
				    nop                                  ; filler
				
				    punpckldq mm1, mm2                   ; packet header | x of vertex
				    mov       eax, [dlp-4]               ; first offset in offset list
				
				    movq      [fifo-8], mm1              ; PCI write packet header | x of vertex
				    movd      mm1, [vertex + Y]          ; 0 | y of vertex
				
				    cmp       eax, 0                     ; offset == 0 (list empty) ?
				    jz        win_datalist_end_ND_WB1    ; yup, no more vertex data, one DWORD in "write buffer"
				
				;;;       while (i != GR_DLIST_END) {
				;;;         TRI_SETF(FARRAY(vPtr, i));
				;;;         dataElem++;
				;;;         i = gc->tsuDataList[dataElem];
				;;;       }
				
				win_datalist_loop_ND_WB1:                ; one DWORD in "write buffer" 
				
				    movd      mm2, [vertex + eax]        ; get next parameter
				    add       fifo, 8                    ; fifoPtr += 2*sizeof(FxU32)
				
				    mov       eax, [dlp]                 ; get next offset from offset list
				    add       dlp, 8                     ; dlp += 2
				
				    punpckldq mm1, mm2                   ; current param | previous param
				    cmp       eax, 0                     ; at end of offset list (offset == 0) ?
				
				    movq      [fifo-8], mm1              ; PCI write current param | previous param
				    jz        win_datalist_end_ND_WB0    ; yes, exit, "write buffer" empty
				
				    movd      mm1, [vertex+eax]          ; get next parameter
				    mov       eax, [dlp-4]               ; get next offset from offset list
				
				    test      eax, eax                   ; at end of offset list (offset == 0) ?
				    jnz       win_datalist_loop_ND_WB1   ; nope, copy next parameter
				
				win_datalist_end_ND_WB1:
				
				    mov       eax, [strideinbytes]       ; get offset to next vertex
				    sub       vertexCount, 1             ; another vertex done. Any left?
				
				    lea       vertex, [vertex + eax]     ; points to next vertex
				    jnz       win_vertex_loop_ND_WB1     ; yup, output next vertex
				
				win_vertex_end_ND_WB1:
				
				    movd      [fifo], mm1                ; flush "write buffer"
				    add       fifo, 4                    ; fifoPtr += sizeof(FxU32)
				
				;;;       TRI_END;
				;;;     Prepare for the next packet (if the strip size is longer than 15)
				;;;       GR_CHECK_SIZE();
				;;;       count -= 15;
				;;;       pktype = SSTCP_PKT3_DDDDDD;
				;;;     }
				
				    mov       ebp, 16                    ; pktype = SSTCP_PKT3_DDDDDD (strip continuation)
				    mov       eax, [gc + fifoPtr]        ; old fifoPtr
				
				    mov       [esp+_pktype], ebp         ; pktype = SSTCP_PKT3_DDDDDD (strip continuation)
				    mov       ebp, [gc + fifoRoom]       ; old number of bytes available in fifo
				
				    mov       vertexCount, [esp + _count]; remaining vertices before previous loop
				    sub       eax, fifo                  ; old fifoPtr - new fifoPtr (fifo room used)
				
				    mov       [gc + fifoPtr], fifo       ; save current fifoPtr 
				    add       ebp, eax                   ; new number of bytes available in fifo
				
				    mov       [gc + fifoRoom], ebp       ; save current number of bytes available in fifo
				    sub       vertexCount, 15            ; remaining number of vertices to process
				
				    mov       [esp + _count], vertexCount; remaining number of vertices to process 
				    test      vertexCount, vertexCount   ; any vertices left to process ?
				
				    nop                                  ; filler
				    jg        win_coords_loop_ND         ; loop if number of vertices to process >= 0
				
				    femms                                ; no more MMX code; clear MMX/FPU state
				
				    pop       ebx                        ; restore caller's register variable
				    pop       ebp                        ; restore frame pointer
				
				    pop       esi                        ; restore caller's register variable
				    pop       edi                        ; restire caller's register variable
				
				    ret       20                         ; return, pop 5 DWORD parameters off stack
				
				    ALIGN 32
				    
				deref_mode:
				
				    femms                                ; we'll use MMX; clear FPU/MMX state
				
				    prefetch  [vertexPtr]                ; pre-load first group of pointers
				
				win_coords_loop_D:
				
				    sub       vertexCount, 15            ; vertexCount >= 15 ? CF=0 : CF=1
				    mov       ecx, [gc + vertexSize]     ; bytes of data for each vertex 
				
				    sbb       eax, eax                   ; vertexCount >= 15 ? 00000000:ffffffff
				
				    and       vertexCount, eax           ; vertexCount >= 15 ? 0 : vertexcount-15
				    add       vertexCount, 15            ; vertexcount >= 15 ? 15 :vertexcount
				
				    imul      ecx, vertexCount           ; total amount of vertex data we'll send
				
				    mov       eax, [gc + fifoRoom]       ; fifo space available
				    add       ecx, 4                     ; add header size ==> total packet size
				
				    cmp       eax, ecx                   ; fifo space avail >= packet size ?
				    jge       win_strip_begin_D          ; yup, start writing strip data
				
				    push      @Line                      ; line number inside this function
				    push      0h                         ; pointer to function name = NULL
				
				    push      ecx                        ; fifo space needed
				    call      __grCommandTransportMakeRoom@12 ; note: updates fifoPtr
				
				        align 32
				win_strip_begin_D:
				;;;     Setup packet header
				;;;
				    mov       eax, vertexCount           ; number of vertices in strip/fan
				    mov       edx, [esp + _type]         ; setup mode
				
				    mov       fifo, [gc + fifoPtr]       ; get fifoPtr
				    shl       edx, 22                    ; <27:22> = setup mode (kSetupStrip or kSetupFan)
				
				    mov       ebp, [gc + cullStripHdr]   ; <2:0> = type
				    shl       eax, 6                     ; <9:6> = vertex count (max 15)
				
				    or        eax, edx                   ; setup mode and vertex count
				    mov       edx, [esp + _pktype]       ; <5:3> = command (SSTCP_PKT3_BDDBDD, SSTCP_PKT3_BDDDDD, or SSTCP_PKT3_DDDDDD)
				
				    or        eax, ebp                   ; setup mode, vertex count, and type
				    mov       ebp, 4                     ; test bit 2
				
				    or        eax, edx                   ; setup mode, vertex count, type, and command
				    lea       dlpStart, [gc+tsuDataList] ; pointer to start of offset list
				
				    test      fifo, ebp                  ; fifoPtr QWORD aligned ?
				    jz        fifo_aligned_D             ; yup
				
				    mov       [fifo], eax                ; PCI write packet type
				    add       fifo, 4                    ; fifo pointer now QWORD aligned
				
				;;;     for (k = 0; k < vcount; k++) {
				;;;       FxI32 i;
				;;;       FxU32 dataElem;
				;;;       float *vPtr;
				;;;       vPtr = pointers;
				;;;       if (mode)
				;;;         vPtr = *(float **)vPtr
				;;;       (float *)pointers += stride;
				;;;       TRI_SETF(FARRAY(vPtr, 0));
				;;;       dataElem = 0;
				;;;       TRI_SETF(FARRAY(vPtr, 4));
				;;;       i = gc->tsuDataList[dataElem];
				
				
				win_vertex_loop_D_WB0:                   ; nothing in "write buffer"
				
				    mov       edx, [vertexPtr]           ; dereference pointer, edx points to vertex
				    add       vertexPtr, 4               ; next pointer
				
				    lea       dlp, [gc + tsuDataList]    ; get pointer to offset list; dlp ++
				    add       dlp, 4                     ; dlp ++
				
				    movq      mm1, [edx + X]             ; get vertex x,y
				    add       fifo, 8                    ; fifo += 2
				
				    mov       eax, [dlp - 4]             ; get first offset from offset list
				    movq      [fifo-8], mm1              ; PCI write x, y
				
				    test      eax, eax                   ; if offset == 0, end of offset list
				    je        win_datalist_end_D_WB0     ; no more vertex data, nothing in "write buffer" 
				
				;;;       while (i != GR_DLIST_END) {
				;;;         TRI_SETF(FARRAY(vPtr, i));
				;;;         dataElem++;
				;;;         i = gc->tsuDataList[dataElem];
				;;;       }
				
				win_datalist_loop_D_WB0:                 ; nothing in "write buffer"
				
				    movd      mm1, [edx + eax]           ; get next parameter
				    mov       eax, [dlp]                 ; get next offset from offset list
				
				    test      eax, eax                   ; at end of offset list (offset == 0) ?
				    jz        win_datalist_end_D_WB1     ; exit, write buffer contains one DWORD
				
				    add       dlp, 8                     ; dlp++
				    movd      mm2, [edx + eax]           ; get next parameter
				
				    mov       eax, [dlp-4]               ; get next offset from offset list
				    add       fifo, 8                    ; fifoPtr += 2*sizeof(FxU32)
				
				    punpckldq mm1, mm2                   ; current param | previous param
				    test      eax, eax                   ; at end of offset list (offset == 0) ?
				
				    movq      [fifo-8], mm1              ; PCI write current param | previous param
				    jnz       win_datalist_loop_D_WB0    ; nope, copy next parameter
				
				win_datalist_end_D_WB0:
				
				    dec       vertexCount                ; another vertex done. Any left?
				    jnz       win_vertex_loop_D_WB0      ; yup, output next vertex
				
				win_vertex_end_D_WB0:
				
				;;;       TRI_END;
				;;;     Prepare for the next packet (if the strip size is longer than 15)
				;;;       GR_CHECK_SIZE();
				;;;       count -= 15;
				;;;       pktype = SSTCP_PKT3_DDDDDD;
				;;;     }
				
				    mov       ebp, 16                    ; pktype = SSTCP_PKT3_DDDDDD (strip continuation)
				    mov       eax, [gc + fifoPtr]        ; old fifoPtr
				
				    mov       [esp + _pktype], ebp       ; pktype = SSTCP_PKT3_DDDDDD (strip continuation)
				    mov       ebp, [gc + fifoRoom]       ; old number of bytes available in fifo
				
				    mov       vertexCount, [esp + _count]; remaining vertices before previous loop
				    sub       eax, fifo                  ; old fifoPtr - new fifoPtr (fifo room used)
				
				    add       ebp, eax                   ; new number of bytes available in fifo
				    mov       [gc + fifoPtr], fifo       ; save current fifoPtr 
				
				    sub       vertexCount, 15            ; remaining number of vertices to process
				    mov       [gc + fifoRoom], ebp       ; save current number of bytes available in fifo
				
				    mov       [esp + _count], vertexCount; remaining number of vertices to process 
				    test      vertexCount, vertexCount   ; any vertices left to process ?
				
				    nop                                  ; filler
				    jg        win_coords_loop_D          ; loop if number of vertices to process >= 0
				
				    femms                                ; no more MMX code; clear MMX/FPU state
				
				    pop       ebx                        ; restore caller's register variable
				    pop       ebp                        ; restore frame pointer
				
				    pop       esi                        ; restore caller's register variable
				    pop       edi                        ; restire caller's register variable
				
				    ret       20                         ; return, pop 5 DWORD parameters off stack
				
				    ALIGN 32
				
				fifo_aligned_D:
				
				    movd      mm1, eax                   ; move header into "write buffer"
				
				win_vertex_loop_D_WB1:                   ; one DWORD in "write buffer"
				
				    mov       edx, [vertexPtr]           ; dereference pointer, edx points to vertex
				    add       vertexPtr, 4               ; next pointer
				
				    add       fifo, 8                    ; fifoPtr += 2*sizeof(FxU32)
				    lea       dlp, [gc + tsuDataList]    ; get pointer to start of offset list
				
				    movd      mm2, [edx + X]             ; 0 | x of vertex
				    add       dlp, 4                     ; dlp++
				 
				    mov       eax, [dlp-4]               ; first offset in offset list
				    punpckldq mm1, mm2                   ; packet header | x of vertex
				
				    movq      [fifo-8], mm1              ; PCI write packet header | x of vertex
				    movd      mm1, [edx + Y]             ; 0 | y of vertex
				
				    test      eax, eax                   ; offset == 0 (list empty) ?
				    je        win_datalist_end_D_WB1     ; yup, no more vertex data, one DWORD in "write buffer"
				
				;;;       while (i != GR_DLIST_END) {
				;;;         TRI_SETF(FARRAY(vPtr, i));
				;;;         dataElem++;
				;;;         i = gc->tsuDataList[dataElem];
				;;;       }
				
				win_datalist_loop_D_WB1:                ; one DWORD in "write buffer" = MM1
				
				    movd      mm2, [edx + eax]          ; get next parameter
				    add       fifo, 8                   ; fifoPtr += 2*sizeof(FxU32)
				
				    mov       eax, [dlp]                ; get next offset from offset list
				    add       dlp, 8                    ; dlp += 2
				
				    punpckldq mm1, mm2                  ; current param | previous param
				    cmp       eax, 0                    ; at end of offset list (offset == 0) ?
				
				    movq      [fifo-8], mm1             ; PCI write current param | previous param
				    jz        win_datalist_end_D_WB0    ; yes, exit, "write buffer" empty
				
				    movd      mm1, [edx + eax]          ; get next parameter
				    mov       eax, [dlp-4]              ; get next offset from offset list
				
				    cmp       eax, 0                    ; at end of offset list (offset == 0) ?
				    jnz       win_datalist_loop_D_WB1   ; nope, copy next parameter
				
				win_datalist_end_D_WB1:
				
				    dec       vertexCount               ; another vertex done. Any left?
				    jnz       win_vertex_loop_D_WB1     ; yup, output next vertex
				
				win_vertex_end_D_WB1:
				
				    movd      [fifo], mm1               ; flush "write buffer"
				    add       fifo, 4                   ; fifoPtr++
				
				;;;       TRI_END;
				;;;     Prepare for the next packet (if the strip size is longer than 15)
				;;;       GR_CHECK_SIZE();
				;;;       count -= 15;
				;;;       pktype = SSTCP_PKT3_DDDDDD;
				;;;     }
				
				    mov       ebp, 16                    ; pktype = SSTCP_PKT3_DDDDDD (strip continuation)
				    mov       eax, [gc + fifoPtr]        ; old fifoPtr
				
				    mov       [esp+_pktype], ebp         ; pktype = SSTCP_PKT3_DDDDDD (strip continuation)
				    mov       ebp, [gc + fifoRoom]       ; old number of bytes available in fifo
				
				    mov       vertexCount, [esp + _count]; remaining vertices before previous loop
				    nop                                  ; filler
				
				    sub       eax, fifo                  ; old fifoPtr - new fifoPtr (fifo room used)
				    mov       [gc + fifoPtr], fifo       ; save current fifoPtr 
				
				    sub       vertexCount, 15            ; remaining number of vertices to process
				    add       ebp, eax                   ; new number of bytes available in fifo
				
				    mov       [gc + fifoRoom], ebp       ; save current number of bytes available in fifo
				    cmp       vertexCount, 0             ; any vertices left to process ?
				
				    mov       [esp + _count], vertexCount; remaining number of vertices to process 
				    jg        win_coords_loop_D          ; loop if number of vertices to process >= 0
				
				    femms                                ; no more MMX code; clear MMX/FPU state
				
				strip_done: 
				    pop       ebx                        ; restore caller's register variable
				    pop       ebp                        ; restore frame pointer
				
				    pop       esi                        ; restore caller's register variable
				    pop       edi                        ; restire caller's register variable
				
				    ret       20                         ; return, pop 5 DWORD parameters off stack
				
				__grDrawVertexList_3DNow_Window@20 ENDP
				
				
				   
				
				    PUBLIC  __grDrawVertexList_3DNow_Clip@20
				__grDrawVertexList_3DNow_Clip@20 PROC NEAR
				; 132  : {
				
				    ALIGN 32
				
				    mov       edx, DWORD PTR fs:[18h]    ; get thread local storage base pointer        
				    push      edi                        ; save caller's register variable
				
				    push      esi                        ; save caller's register variable
				    mov       vertexCount, [esp+_count-8]; number of vertices in strip/fan
				
				    push      ebp                        ; save frame pointer
				    mov       ebp, [__GlideRoot + tlsOffset]; GC position relative to tls base    
				
				    push      ebx                        ; save caller's register variable        
				    mov       vertexPtr, [esp+_pointers] ; get current vertex pointer (deref mode)
				                                         ; get current vertex (non-deref mode)
				    
				    mov       gc, [edx + ebp]            ; get current graphics context from tls
				    test      vertexCount, vertexCount   ; number of vertices <= 0 ?
				
				    jle       strip_done                 ; yup, the strip/fan is done
				  
				;;;     vSize = gc->state.vData.vSize
				;;;     if (stride == 0)
				;;;       stride = gc->state.vData.vStride;
				
				;; We can operate in one of two modes:
				;;
				;; 0. We are stepping through an array of vertices, in which case
				;; the stridesize is equal to the size of the vertex data, and
				;; always > 4, since vertex data must a least contain x,y (ie 8 bytes).
				;; vertexPtr is pointing to the array of vertices.
				;;
				;; 1. We are stepping through an array of pointers to vertices
				;; in which case the stride is 4 bytes and we need to dereference
				;; the pointers to get at the vertex data. vertexPtr is pointing
				;; to the array of pointers to vertices.
				
				    mov       edx, [esp + _mode]         ; get mode (0 or 1)
				    mov       eax, [gc + vertexSize]     ; size of vertex data in bytes
				
				    test      edx, edx                   ; mode 0 (array of vertices) ?
				    mov       edx, [gc + vertexStride]   ; get stride in DWORDs
				
				    movd      mm6, [__GlideRoot+pool_f255]; GlideRoot.pool.f255     
				    mov       [strideinbytes], 4         ; array of pointers    
				        
				    jnz       clip_coords_begin          ; nope, it's mode 1
				
				clip_coordinates_ND:
				
				    shl       edx, 2                     ; stride in bytes
				    mov       [strideinbytes], edx       ; save off stride (in bytes)
				
				    align   32
				clip_coords_begin:
				
				dataElem      textequ <ebp>              ; number of vertex components processed    
				
				;;;   {
				;;;     float oow;
				;;;       while (count > 0) {
				;;;       FxI32 k, vcount = count >= 15 ? 15 : count;
				
				    sub       vertexCount, 15            ; vertexCount >= 15 ? CF=0 : CF=1
				    mov       ecx, [gc + vertexSize]     ; bytes of data for each vertex 
				
				    sbb       eax, eax                   ; vertexCount >= 15 ? 00000000:ffffffff
				    and       vertexCount, eax           ; vertexCount >= 15 ? 0 : vertexcount-15
				
				    mov       eax, [gc+fifoRoom]         ; fifo space available
				    add       vertexCount, 15            ; vertexcount >= 15 ? 15 :vertexcount
				
				    imul      ecx, vertexCount           ; total amount of vertex data we'll send
				
				    add       ecx, 4                     ; add header size ==> total packet size
				    nop                                  ; filler
				
				    cmp       eax, ecx                   ; fifo space avail >= packet size ?
				    jge       clip_strip_begin           ; yup, start writing strip data
				
				    push      @Line                      ; line number inside this function
				    push      0h                         ; pointer to function name = NULL
				
				    push      ecx                        ; fifo space needed
				    call      __grCommandTransportMakeRoom@12 ; note: updates fifoPtr
				
				        align 32
				clip_strip_begin:
				;;;     TRI_STRIP_BEGIN(type, vcount, vSize, pktype)
				
				    mov       edx, [esp + _type]         ; setup mode
				    mov       eax, vertexCount           ; number of vertices in strip/fan
				
				    mov       fifo, [gc + fifoPtr]       ; get fifoPtr
				    shl       eax, 6                     ; <9:6> = vertex count (max 15)
				
				    mov       ebp, [gc + cullStripHdr]   ; <2:0> = type
				    shl       edx, 22                    ; <27:22> = setup mode (kSetupStrip or kSetupFan)
				
				    or        eax, edx                   ; setup mode and vertex count
				    mov       edx, [esp + _pktype]       ; <5:3> = command (SSTCP_PKT3_BDDBDD, SSTCP_PKT3_BDDDDD, or SSTCP_PKT3_DDDDDD)
				
				    or        eax, ebp                   ; setup mode, vertex count, and type
				    add       fifo, 4                    ; fifoPtr += sizeof(FxU32)
				
				    or        eax, edx                   ; setup mode, vertex count, type, and command
				    mov       [fifo-4], eax              ; PCI write header
				
				;;;     for (k = 0; k < vcount; k++) {
				;;;       float *vPtr
				;;;       vPtr = pointers
				  
				clip_for_begin:
				
				;;;       if (mode)
				;;;         vPtr = *(float **)vPtr
				
				    mov       edx, vertexPtr             ; vertex = vertexPtr (assume no-deref mode)
				    mov       eax, [esp+_mode]           ; mode 0 = no deref, mode 1 = deref
				
				    mov       [vertices], vertexCount    ; save numnber of vertices
				    test      eax, eax                   ; deref mode ?
				
				    mov       eax, [gc+wInfo_offset]     ; get offset of W into vertex struct
				    jz        clip_noderef               ; yup, no-deref mode
				
				    mov       edx, [vertexPtr]           ; vertex = *vertexPtr
				    lea       esp, [esp]                 ; filler
				
				clip_noderef:
				
				;;;       oow = 1.0f / FARRAY(vPtr, gc->state.vData.wInfo.offset)
				
				    movd      mm0, [edx+eax]             ; 0 | W of current vertex
				    pfrcp     mm1, mm0                   ; 0 | 1/W approx
				
				    mov       ebp, [strideinbytes]       ; offset to next vertex/vertexPtr
				    movq      mm2, [edx]                 ; y | x of current vertex
				
				    pfrcpit1  mm0, mm1                   ; 0 | 1/W refine
				    movq      mm3, [gc+vp_hwidth]        ; gc->state.Viewport.hheight | gc->state.Viewport.hwidth
				
				    movq      mm4, [gc+vp_ox]            ; gc->state.Viewport.oy | gc->state.Viewport.ox
				    add       vertexPtr, ebp             ; point to next vertex/VertexPtr
				
				    pfrcpit2  mm0, mm1                   ; oow = 1.0f / FARRAY(vPtr, gc->state.vData.wInfo.offset
				    mov       esi, [gc+paramIndex]       ; gc->state.paramIndex
				
				;;;       /* x, y */
				;;;       TRI_SETF(FARRAY(vPtr, 0)
				;;;         *oow*gc->state.Viewport.hwidth + gc->state.Viewport.ox)
				;;;       TRI_SETF(FARRAY(vPtr, 4)
				;;;         *oow*gc->state.Viewport.hheight + gc->state.Viewport.oy)
				
				    pfmul     mm2, mm3                   ; TRI_SETF(FARRAY(vPtr,0)*state.Viewport.hheight | TRI_SETF(FARRAY(vPtr,4)*state.Viewport.hwidth
				    xor       dataElem, dataElem         ; dataElem = 0
				
				    add       fifo, 8                    ; fifoPtr += 2*sizeof(FxFloat)
				    punpckldq mm0, mm0                   ; oow | oow
				
				    pfmul     mm2, mm0                   ; TRI_SETF(FARRAY(vPtr, 4)*oow*gc->state.Viewport.height | TRI_SETF(FARRAY(vPtr, 0)*oow*gc->state.Viewport.hwidth
				    pfadd     mm2, mm4                   ; TRI_SETF(FARRAY(vPtr, 4)*oow*gc->state.Viewport.hheight + gc->state.Viewport.oy) |
				
				    test      esi, 3                     ; STATE_REQUIRES_IT_DRGB | STATE_REQUIRES_IT_ALPHA ?
				    mov       eax, [gc+tsuDataList]      ; first entry from offset list
				
				;;;       (float *)pointers += stride
				;;;       TRI_VP_SETFS(vPtr, oow);
				
				    movq      [fifo-8], mm2              ; PCI write transformed x, y
				    jz        clip_setup_ooz             ; nope, no color at all needed
				  
				    cmp       DWORD PTR [gc+colorType], 0; gc->state.vData.colorType == GR_FLOAT ?
				    jne       clip_setup_pargb           ; nope, packed ARGB format
				  
				    test      esi, 1                     ; STATE_REQUIRES_IT_DRGB ?
				    jz        clip_setup_a               ; no, but definitely A
				
				    movd      mm2, [edx + eax]           ; 0 | r
				    mov       eax, [gc+tsuDataList+4]    ; offset of g part of vertex data
				
				    pfmul     mm2, mm6                   ; 0 | r * 255.0f
				    movd      mm3, [edx + eax]           ; 0 | g
				
				    mov       eax, [gc+tsuDataList+8]    ; offset of b part of vertex data
				    movd      [fifo], mm2                ; PCI write r*255
				
				    pfmul     mm3, mm6                   ; 0 | g * 255.0f
				    movd      mm2, [edx + eax]           ; 0 | b
				
				    movd      [fifo+4], mm3              ; PCI write g*255
				    mov       dataElem, 12               ; dataElem = 3
				
				    pfmul     mm2, mm6                   ; 0 | b * 255.0f
				    mov       eax, [gc+tsuDataList+12]   ; offset of A part of vertex data
				
				    test      esi, 2                     ; STATE_REQUIRES_IT_ALPHA ?
				    lea       fifo, [fifo+12]            ; fifoPtr += 3*sizeof(FxFloat)
				
				    movd      [fifo-4], mm2              ; PCI write b*255
				    jz        clip_setup_ooz             ; nope, no alpha, proceeed with ooz
				
				clip_setup_a:
				    movd      mm2, [eax+edx]             ; 0 | a
				    add       fifo, 4                    ; fifoPtr += sizeof(FxFloat)
				
				    mov       esp, esp                   ; filler
				    add       dataElem, 4                ; dataElem++ 
				
				    pfmul     mm2, mm6                   ; 0 | a * 255.0f
				    mov       eax, [gc+dataElem+tsuDataList]; offset of next part of vertex data
				
				    movd      [fifo-4], mm2              ; PCI write a*255
				    jmp       clip_setup_ooz             ; check whether we need to push out z
				
				    ALIGN     32
				
				clip_setup_pargb:
				    movd      mm2, [eax+edx]             ; get packed ARGB data
				    add       fifo, 4                    ; fifoPtr += sizeof(FxU32)
				
				    mov       dataElem, 4                ; dataElem = 1 (namely pargb)
				    mov       eax, [gc+tsuDataList+4]    ; offset of next part of vertex data
				
				    movd      [fifo-4], mm2              ; PCI write packed ARGB
				
				clip_setup_ooz:
				  
				    test      esi, 4                     ; STATE_REQUIRES_OOZ ?
				    jz        clip_setup_qow             ; nope
				
				    test      DWORD PTR[gc+fbi_fbzMode],200000h ; gc->state.fbi_config.fbzMode & SST_DEPTH_FLOAT_SEL != 0 ?
				    je        clip_setup_ooz_nofog       ; nope
				
				    cmp       DWORD PTR[gc+qInfo_mode], 0; gc->state.vData.qInfo.mode == GR_PARAM_ENABLE ?
				    jz        clip_setup_fog_oow         ; nope
				
				    mov       eax, [gc + qInfo_offset]   ; offset of Q component of vertex
				    add       fifo, 4                    ; fifoPtr += sizeof(FxFloat)
				
				    add       dataElem, 4                ; dataElem++
				    movd      mm2, [edx + eax]           ; 0 | q of vertex
				
				    mov       eax,[gc+dataElem+tsuDataList]; pointer to next vertex component
				    pfmul     mm2, mm0                   ; 0 | q*oow
				
				    movd      [fifo-4], mm2              ; PCI write transformed Q
				    jmp       clip_setup_qow             ; check whether we need to write Q or W
				
				clip_setup_fog_oow:
				
				    add       fifo, 4                    ; fifoPtr += sizeof(FxFloat) 
				    add       dataElem, 4                ; dataElem++
				
				    movd      mm3, [gc + depth_range]    ;
				    pfmul     mm3, mm0                   ; 
				
				    movd      mm4, [gc + depth_range]    ; depth range
				    pfsub     mm4, mm3                   ; 
				
				    movd      [fifo-4], mm4              ; PCI write oow
				    mov       eax,[gc+dataElem+tsuDataList]; pointer to next vertex component
				
				    jmp       clip_setup_qow             ; check whether we need to write Q or W
				
				clip_setup_ooz_nofog:
				
				    movd      mm2, [eax + edx]           ; 0 | z component of vertex
				    add       fifo, 4                    ; fifoPtr += sizeof(FxFloat)
				
				    add       dataElem, 4                ; dataElem += 1
				    movd      mm3, [gc + vp_hdepth]      ; 0 | gc->state.Viewport.hdepth
				
				    pfmul     mm2, mm0                   ; TRI_SETF(FARRAY(_s, i)*_oow
				    movd      mm4, [gc + vp_oz]          ; 0 | gc->state.Viewport.oz
				
				    pfmul     mm2, mm3                   ; 0 | TRI_SETF(FARRAY(_s, i)*_oow*gc->state.Viewport.hdepth
				    mov       eax, [gc+dataElem+tsuDataList]; offset of next vertex component
				
				    pfadd     mm2, mm4                   ; 0 | TRI_SETF(FARRAY(_s, i)*_oow*gc->state.Viewport.hdepth+gc->state.Viewport.oz
				    movd      [fifo-4], mm2              ; PCI write transformed Z
				
				clip_setup_qow:
				    test      esi, 8                     ; STATE_REQUIRES_OOW_FBI ?
				    jz        clip_setup_qow0            ; nope
				
				    cmp       DWORD PTR[gc+fogInfo_mode],0; gc->state.vData.fogInfo.mode == GR_PARAM_ENABLE ?
				    jz        clip_setup_oow_nofog       ; nope, no fog
				
				    mov       eax, [gc + fogInfo_offset] ; offset of fogInfo component of vertex
				    add       fifo, 4                    ; fifoPtr += sizeof(FxFloat)
				
				    add       dataElem, 4                ; dataElem++
				    movd      mm2, [edx + eax]           ; 0 | fogInfo of vertex
				
				    mov       eax,[gc+dataElem+tsuDataList]; pointer to next vertex component
				    pfmul     mm2, mm0                   ; fogInfo*oow
				
				    movd      [fifo-4], mm2              ; PCI write transformed Q
				    jmp       clip_setup_qow0            ; continue with q0
				
				clip_setup_oow_nofog:
				
				    cmp       DWORD PTR [gc+qInfo_mode],0; does vertex have Q component ?
				    je        clip_setup_oow             ; nope, not Q but W
				
				    add       fifo, 4                    ; fifoPtr += sizeof(FxFloat)
				    mov       eax, [gc+qInfo_offset]     ; offset of Q component of vertex
				
				    add       dataElem, 4                ; dataElem++
				    movd      mm2, [edx+eax]             ; 0 | q of vertex
				
				    mov       eax,[gc+dataElem+tsuDataList]; pointer to next vertex component
				    pfmul     mm2, mm0                   ; q*oow
				
				    movd      [fifo-4], mm2              ; PCI write transformed Q
				    jmp       clip_setup_qow0            ; continue with q0
				
				    ALIGN     32
				
				clip_setup_oow:
				    add       fifo, 4                    ; fifoPtr += sizeof(FxFloat) 
				    add       dataElem, 4                ; dataElem++
				
				    movd      [fifo-4], mm0              ; PCI write oow
				    mov       eax,[gc+dataElem+tsuDataList]; pointer to next vertex component
				
				clip_setup_qow0:
				    test      esi, 16                    ; STATE_REQUIRES_W_TMU0 ?
				    jz        clip_setup_stow0           ; nope 
				
				    cmp       DWORD PTR [gc+q0Info_mode],0; does vertex have Q component ?
				    je        clip_setup_oow0            ; nope, not Q but W
				
				    mov       eax, [gc+q0Info_offset]    ; offset of Q component of vertex
				    add       fifo, 4                    ; fifoPtr += sizeof(FxFloat)
				
				    add       dataElem, 4                ; dataElem++
				    movd      mm2, [edx+eax]             ; 0 | q0 of vertex
				
				    mov       eax,[gc+dataElem+tsuDataList]; pointer to next vertex component
				    pfmul     mm2, mm0                   ; q0*oow
				
				    movd      [fifo-4], mm2              ; PCI write transformed q0
				    jmp       clip_setup_stow0           ; continue with stow0
				
				    ALIGN     32
				
				clip_setup_oow0:
				    add       fifo, 4                    ; fifoPtr += sizeof(FxFloat) 
				    add       dataElem, 4                ; dataElem++
				
				    movd      [fifo-4], mm0              ; PCI write oow
				    mov       eax,[gc+dataElem+tsuDataList]; pointer to next vertex component
				
				clip_setup_stow0:
				
				    test      esi, 32                    ; STATE_REQUIRES_ST_TMU0 ?
				    jz        clip_setup_qow1            ; nope
				
				    movq      mm7, [gc + tmu0_s_scale]   ; state.tmu_config[0].t_scale | state.tmu_config[0].s_scale
				    add       fifo, 8                    ; fifoPtr += 2*sizeof(FxFloat)
				
				    movd      mm2, [edx+eax]             ; param1
				    mov       eax,[gc+dataElem+tsuDataList+4];pointer to next vertex component
				
				    pfmul     mm7, mm0                   ; oow*tmu0_t_scale | oow*tmu0_s_scale
				    add       dataElem, 8                ; dataElem += 2
				
				    movd      mm3, [edx+eax]             ; param2
				    punpckldq mm2, mm3                   ; param2 | param1
				
				    pfmul     mm2, mm7                   ; param2*oow*tmu0_t_scale | param1*oow*tmu0_s_scale
				
				    movq      [fifo-8], mm2              ; PCI write param2*oow*tmu0_t_scale | param1*oow*tmu0_s_scale 
				    mov       eax, [gc+dataElem+tsuDataList]; pointer to next vertex component
				
				clip_setup_qow1:
				    test      esi, 64                    ; STATE_REQUIRES_W_TMU1 ?
				    jz        clip_setup_stow1           ; nope
				
				    cmp       DWORD PTR [gc+q1Info_mode],0; does vertex have Q component ?
				    je        clip_setup_oow1            ; nope, not Q but W
				
				    mov       eax, [gc+q1Info_offset]    ; offset of Q component of vertex
				    add       fifo, 4                    ; fifoPtr += sizeof(FxFloat)
				
				    add       dataElem, 4                ; dataElem++
				    movd      mm2, [edx+eax]             ; 0 | q1 of vertex
				
				    mov       eax,[gc+dataElem+tsuDataList]; pointer to next vertex component
				    pfmul     mm2, mm0                   ; q1*oow
				
				    movd      [fifo-4], mm2              ; PCI write transformed q1
				    jmp       clip_setup_stow1           ; continue with stow1
				
				    ALIGN     32
				
				clip_setup_oow1:
				    add       fifo, 4                    ; fifoPtr += sizeof(FxFloat) 
				    add       dataElem, 4                ; dataElem++
				
				    movd      [fifo-4], mm0              ; PCI write oow
				    mov       eax,[gc+dataElem+tsuDataList]; pointer to next vertex component
				
				clip_setup_stow1:
				
				    test      esi, 128                   ; STATE_REQUIRES_ST_TMU1 ?
				    mov       vertexCount, [vertices]    ; get number of vertices
				
				    movq      mm7, [gc + tmu1_s_scale]   ; state.tmu_config[1].t_scale | state.tmu_config[1].s_scale
				    jz        clip_setup_end             ; nope
				
				    movd      mm2, [edx+eax]             ; param1
				    add       fifo, 8                    ; fifoPtr += 2*sizeof(FxFloat)
				
				    mov       eax,[gc+dataElem+tsuDataList+4]; pointer to next vertex component
				    pfmul     mm7, mm0                   ; oow*state.tmu_config[1].t_scale | oow*state.tmu_config[1].s_scale
				
				    movd      mm3, [edx+eax]             ; param2
				    punpckldq mm2, mm3                   ; param2 | param1
				
				    pfmul     mm2, mm7                   ; param2*oow*state.tmu_config[1].t_scale | param1*oow*state.tmu_config[1].s_scale
				    movq      [fifo-8], mm2              ; PCI write param2*oow*state.tmu_config[1].t_scale | param1*oow*state.tmu_config[1].s_scale
				
				clip_setup_end:
				
				; 206  :       for (k = 0; k < vcount; k++) {
				
				    dec       vertexCount                ; vcount--
				    jnz       clip_for_begin             ; until 
				clip_for_end:
				
				; 221  :       }
				; 222  :       TRI_END;
				
				    mov       eax, [gc + fifoPtr]        ; old fifoPtr
				    mov       esp, esp                   ; filler
				
				    nop                                  ; filler
				    mov       ebp, [gc + fifoRoom]       ; old number of bytes available in fifo
				
				    mov       vertexCount, [esp + _count]; remaining vertices before previous loop
				    sub       eax, fifo                  ; old fifoPtr - new fifoPtr (fifo room used)
				
				    mov       [gc + fifoPtr], fifo       ; save current fifoPtr 
				    add       ebp, eax                   ; new number of bytes available in fifo
				
				    sub       vertexCount, 15            ; remaining number of vertices to process
				    mov       [gc + fifoRoom], ebp       ; save current number of bytes available in fifo
				
				    mov       [esp + _count], vertexCount; remaining number of vertices to process 
				    cmp       vertexCount, 0             ; any vertices left to process ?
				
				    mov       DWORD PTR [esp+_pktype], 16; pktype = SSTCP_PKT3_DDDDDD (strip continuation)
				    jg        clip_coords_begin          ; loop if number of vertices to process >= 0
				
				    femms                                ; no more MMX code; clear MMX/FPU state    
				
				strip_done:
				;;;    }
				;;;  #undef FN_NAME
				;;;  } /* _grDrawVertexList */
				
				    pop       ebx                        ; restore caller's register variable
				    pop       ebp                        ; restore frame pointer 
				
				    pop       esi                        ; restore caller's register variable
				    pop       edi                        ; restore caller's register variable
				
				    ret       20                         ; return, pop 5 DWORD parameters off stack
				
				__grDrawVertexList_3DNow_Clip@20 ENDP
				
				_TEXT    ENDS
				
				;;--------------------------------------------------------------------------
				;; end AMD3D version
				;;--------------------------------------------------------------------------
				endif ; GL_AMD3D
				
				;;--------------------------------------------------------------------------
				;; start original code
				;;--------------------------------------------------------------------------
				
				ifndef GL_AMD3D
				
				TITLE   xdraw3.asm
				.586P
				;;; include listing.inc
				INCLUDE fxgasm.h
			      C 
			      C ;----------------------------------------------------------------------
			      C ; Assembler offsets for SSTREGS struct
			      C ;----------------------------------------------------------------------
			      C 
			      C 
			      C 
			      C ;----------------------------------------------------------------------
			      C ; Assembler offsets for GC struct
			      C ;----------------------------------------------------------------------
			      C 
 = 0074			      C base_ptr		= 00000074h
 = 0078			      C reg_ptr			= 00000078h
 = 0080			      C lfb_ptr			= 00000080h
 = 01E0			      C cull_mode		= 000001e0h
 = 96AC			      C checkPtr			= 000096ach
 = 0124			      C tsuDataList		= 00000124h
 = 0DD8			      C triPacketHdr	= 00000dd8h
 = 0DDC			      C cullStripHdr	= 00000ddch
 = 0DE0			      C paramMask	= 00000de0h
 = 0E04			      C fifoStart	= 00000e04h
 = 0E08			      C fifoEnd	= 00000e08h
 = 0E0C			      C fifoOffset	= 00000e0ch
 = 0E10			      C fifoSize	= 00000e10h
 = 0E14			      C fifoJmpHdr	= 00000e14h
 = 0DE4			      C fifoPtr	= 00000de4h
 = 0DE8			      C fifoRead	= 00000de8h
 = 0DEC			      C fifoRoom	= 00000dech
 = 0E1C			      C roomToReadPtr	= 00000e1ch
 = 0E20			      C roomToEnd	= 00000e20h
 = 0E24			      C lfbLockCount	= 00000e24h
 = 0DC4			      C triSetupProc	= 00000dc4h
 = 0DC8			      C drawTrianglesProc	= 00000dc8h
 = 0DC4			      C drawVertexList	= 00000dc4h
 = 0B70			      C vertexSize	= 00000b70h
 = 0B6C			      C vertexStride	= 00000b6ch
 = 0B78			      C invalid	= 00000b78h
 = 0D98			      C CoordinateSpace	= 00000d98h
 = 01E4			      C paramIndex	= 000001e4h
 = 0B00			      C vp_hwidth	= 00000b00h
 = 0B04			      C vp_hheight	= 00000b04h
 = 0B08			      C vp_hdepth	= 00000b08h
 = 0AF4			      C vp_ox	= 00000af4h
 = 0AF8			      C vp_oy	= 00000af8h
 = 0AFC			      C vp_oz	= 00000afch
 = 0B74			      C colorType	= 00000b74h
 = 0B20			      C wInfo_offset	= 00000b20h
 = 0B54			      C qInfo_mode	= 00000b54h
 = 0B58			      C qInfo_offset	= 00000b58h
 = 0B60			      C q0Info_offset	= 00000b60h
 = 0B68			      C q1Info_offset	= 00000b68h
 = 0B5C			      C q0Info_mode	= 00000b5ch
 = 0B64			      C q1Info_mode	= 00000b64h
 = 0B30			      C fogInfo_offset	= 00000b30h
 = 0B2C			      C fogInfo_mode	= 00000b2ch
 = 0A44			      C depth_range	= 00000a44h
 = 0A0C			      C tmu0_s_scale	= 00000a0ch
 = 0A10			      C tmu0_t_scale	= 00000a10h
 = 0A28			      C tmu1_s_scale	= 00000a28h
 = 0A2C			      C tmu1_t_scale	= 00000a2ch
 = 0210			      C fbi_fbzMode	= 00000210h
 = 004C			      C curTriSize		= 0000004ch
 = 000C			      C trisProcessed		= 0000000ch
 = 0010			      C trisDrawn		= 00000010h
 = 96BC			      C lostContext		= 000096bch
 = 96C4			      C windowed		= 000096c4h
 = 011C			      C bInfo		= 0000011ch
			      C 
			      C ;----------------------------------------------------------------------
			      C ; Assembler offsets for GlideRoot struct
			      C ;----------------------------------------------------------------------
			      C 
 = 0000			      C p6Fencer		= 00000000h
 = 000C			      C current_sst		= 0000000ch
 = 0010			      C CPUType			= 00000010h
 = 0008			      C tlsOffset			= 00000008h
 = 002C			      C pool_f255	= 0000002ch
 = 0028			      C pool_f1	= 00000028h
 = 0BBC			      C SIZEOF_GrState		= 00000bbch
 = 9714			      C SIZEOF_GC		= 00009714h
			      C 
 = 000BCFC4		      C SIZEOF_GlideRoot	= 000bcfc4h
			      C 
			      C 
				
 00000000			CONST   SEGMENT
 00000000 3F800000		_F1    DD      03f800000r                      ; 1
 00000004 43800000		_F256  DD      043800000r                      ; 256
				
 00000008 3F800000		_VPF1    DD      03f800000r                      ; 1
 0000000C 43800000		_VPF256  DD      043800000r                      ; 256    
 0010				CONST   ENDS
				
 00000000			_DATA   SEGMENT
 00000000 00000000		vSize           DD    0
 00000004 00000000		ccoow           DD    0
 00000008 00000000		packetVal       DD    0
 0000000C 00000000		strideinbytes   DD    0
				
				
 00000010 00000000		oowa            DD    0
 00000014 00000000		vPtr0           DD    0
 00000018 00000000		vPtr1           DD    0
 0000001C 00000000		vPtr2           DD    0
 0020				_DATA    ENDS
				
 00000000			_TEXT       SEGMENT PAGE PUBLIC USE32 'CODE'
				            ASSUME DS: FLAT, SS: FLAT
				    
 = 00000014			_pktype = 20
 = 00000018			_type = 24
 = 0000001C			_mode = 28
 = 00000020			_count = 32
 = 00000024			_pointers = 36
				
 = esi				gc                 TEXTEQU     <esi>       ; points to graphics context
 = ecx				fifo               TEXTEQU     <ecx>       ; points to next entry in fifo
 = ebp				dlp                TEXTEQU     <ebp>       ; points to dataList structure
 = ebx				vertexCount        TEXTEQU     <ebx>       ; Current vertex counter in the packet
 = edi				vertexPtr          TEXTEQU     <edi>       ; Current vertex pointer
				
				        ALIGN 32
				
				        PUBLIC __drawvertexlist@20
 00000000			__drawvertexlist@20 PROC NEAR
				; 132  : {
				
 00000000  64: A1		        mov     eax, DWORD PTR fs:[18h]; get thread local storage base pointer        
	   00000018
 00000006  56			        push    esi
				
 00000007  8B 35 00000008 E	        mov     esi, [__GlideRoot + tlsOffset]; GC position relative to tls base
 0000000D  57			        push    edi
				    
 0000000E  8B 34 06		        mov     gc, DWORD PTR [eax + esi]    
 00000011  53			        push    ebx
				
				;;;     GR_DCL_GC
				;;;     vSize = gc->state.vData.vSize
				;;;     if (stride == 0)
				;;;       stride = gc->state.vData.vStride;
 00000012  55			        push    ebp            
 00000013  8B 8E 00000B70	        mov     ecx, DWORD PTR [gc+vertexSize]
				    
 00000019  8B 54 24 1C		        mov     edx, DWORD PTR [esp+_mode]
 0000001D  8B 5C 24 20		        mov     vertexCount, DWORD PTR [esp+_count]
				    
 00000021  8B 7C 24 24		        mov     vertexPtr, DWORD PTR [esp+_pointers]
 00000025  89 0D 00000000 R	        mov     DWORD PTR vSize, ecx
				
 0000002B  C1 E2 02		        shl     edx, 2
				;;;     mov     ecx, DWORD PTR [gc+CoordinateSpace]
 0000002E  85 D2		          test    edx, edx
 00000030  75 0A		        jne     SHORT no_stride
 00000032  8B 96 00000B6C	        mov     edx, DWORD PTR [gc+vertexStride]
 00000038  C1 E2 02		        shl     edx, 2
				
				        align 4
 0000003C			no_stride:
				
				;;;     Draw the first (or possibly only) set.  This is necessary because
				;;;     the packet is 3_BDDDDDD, and in the next set, the packet is 3_DDDDDD
				;;;     We try to make tstrip code simple to read. We combine the original code
				;;;     into a single loop by adding an extra packet type assignment at the end of the loop.
				;;; 
				;;;     if (gc->state.grCoordinateSpaceArgs.coordinate_space_mode == GR_WINDOW_COORDS) {
				
				;;;     test    ecx, ecx
 0000003C  89 15 0000000C R	          mov     DWORD PTR strideinbytes, edx
				
				;;;       while (count > 0) {
				;;;         FxI32 k, vcount = count >= 15 ? 15 : count;
				;;;         GR_SET_EXPECTED_SIZE(vcount * vSize, 1);
				;;;         TRI_STRIP_BEGIN(type, vcount, vSize, pktype);
				
 00000042  8B 44 24 20		        mov     eax, DWORD PTR [esp+_count]
				;;;       jne     clip_coordinates
				
 00000046  85 C0		        test    eax, eax
 00000048  0F 8E 000000DC	          jle     strip_done
				
				        align 4
 00000050			window_coords_begin:
				
 00000050  83 FB 0F		        cmp     vertexCount, 15                 ; 0000000fH
 00000053  7C 07		          jl      SHORT win_partial_packet
 00000055  BB 0000000F		        mov     vertexCount, 15                 ; 0000000fH
				
				        align 4
 0000005C			win_partial_packet:
				
 0000005C  A1 00000000 R	        mov     eax, DWORD PTR vSize
 00000061  8B 8E 00000DEC	        mov     ecx, DWORD PTR [gc+fifoRoom]
 00000067  0F AF C3		        imul    eax, vertexCount
 0000006A  83 C0 04		        add     eax, 4
 0000006D  3B C8		        cmp     ecx, eax
 0000006F  7D 0F		        jge     SHORT win_strip_begin
 00000071  68 00000901		        push    @Line
 00000076  6A 00		        push    0h
 00000078  50			        push    eax
 00000079  E8 00000000 E	        call    __grCommandTransportMakeRoom@12
				        
				        align 4
 00000080			win_strip_begin:
				
				;;;     Setup pacet header
				;;;
 00000080  8B 8E 00000DE4	        mov     fifo, DWORD PTR [gc+fifoPtr]
 00000086  8B C3		          mov     eax, vertexCount
 00000088  8B 54 24 18		        mov     edx, DWORD PTR [esp+_type]
 0000008C  8B AE 00000DDC	          mov     ebp, DWORD PTR [gc+cullStripHdr]
 00000092  C1 E2 16		        shl     edx, 22                 ; 00000010H
 00000095  83 C1 04		          add     fifo, 4
 00000098  C1 E0 06		        shl     eax, 6
 0000009B  0B EA		          or    ebp, edx
 0000009D  0B C5		        or      eax, ebp
 0000009F  8B 54 24 14		          mov     edx, DWORD PTR [esp+_pktype]
 000000A3  0B C2		        or      eax, edx
 000000A5  90			          nop
 000000A6  89 41 FC		        mov     DWORD PTR [fifo-4], eax
				
				;;;     for (k = 0; k < vcount; k++) {
				;;;       FxI32 i;
				;;;       FxU32 dataElem;
				;;;       float *vPtr;
				;;;       vPtr = pointers;
				;;;       if (mode)
				;;;         vPtr = *(float **)vPtr
				;;;       (float *)pointers += stride;
				;;;       TRI_SETF(FARRAY(vPtr, 0));
				;;;       dataElem = 0;
				;;;       TRI_SETF(FARRAY(vPtr, 4));
				;;;       i = gc->tsuDataList[dataElem];
				
				        align 4
 000000AC			win_for_begin:
				
 000000AC  8B D7		        mov     edx, vertexPtr
 000000AE  A1 0000000C R	          mov     eax, DWORD PTR strideinbytes
 000000B3  83 F8 04		        cmp     eax, 4
 000000B6  75 04		          jne     SHORT win_no_deref
 000000B8  8B 17		        mov     edx, DWORD PTR [vertexPtr]
				
				        align 4
 000000BC			win_no_deref:
				
 000000BC  83 C1 08		        add     fifo, 8
 000000BF  03 F8		          add     vertexPtr, eax
				
 000000C1  8B 02		        mov     eax, DWORD PTR [edx]
 000000C3  8B 6A 04		          mov     ebp, DWORD PTR [edx+4]
				        
 000000C6  89 41 F8		        mov     DWORD PTR [fifo-8], eax
 000000C9  8B 86 00000124	          mov     eax, DWORD PTR [gc+tsuDataList]
				
 000000CF  89 69 FC		        mov     DWORD PTR [fifo-4], ebp
				  
 000000D2  85 C0		          test    eax, eax
 000000D4  8D AE 00000124	        lea     dlp, DWORD PTR [gc+tsuDataList]
 000000DA  74 14		          je      SHORT win_datalist_end
				  
				        align 4
				
				;;;       while (i != GR_DLIST_END) {
				;;;         TRI_SETF(FARRAY(vPtr, i));
				;;;         dataElem++;
				;;;         i = gc->tsuDataList[dataElem];
				;;;       }
				
 000000DC			win_datalist_begin:
				
 000000DC  83 C1 04		        add     fifo, 4
 000000DF  83 C5 04		          add     dlp, 4
				
 000000E2  8B 04 10		        mov     eax, DWORD PTR [edx+eax]
 000000E5  90			          nop
				
 000000E6  89 41 FC		        mov     DWORD PTR [fifo-4], eax
 000000E9  8B 45 00		          mov     eax, DWORD PTR [dlp]
				
				
 000000EC  85 C0		        test    eax, eax
 000000EE  75 EC		          jne     SHORT win_datalist_begin
 000000F0			win_datalist_end:
				
 000000F0  4B			        dec     vertexCount
 000000F1  75 B9		          jne     SHORT win_for_begin
 000000F3			win_for_end:
				
				;;;       TRI_END;
				;;;     Prepare for the next packet (if the strip size is longer than 15)
				;;;       GR_CHECK_SIZE();
				;;;       count -= 15;
				;;;       pktype = SSTCP_PKT3_DDDDDD;
				;;;     }
				  
 000000F3  8B 86 00000DE4	        mov     eax, DWORD PTR [gc+fifoPtr]
 000000F9  8B 96 00000DEC	          mov     edx, DWORD PTR [gc+fifoRoom]
 000000FF  2B C1		        sub     eax, fifo
 00000101  8B 5C 24 20		          mov     vertexCount, DWORD PTR [esp+_count]
 00000105  03 D0		        add     edx, eax
 00000107  83 EB 0F		          sub     vertexCount, 15                 ; 0000000fH
				  
 0000010A  89 96 00000DEC	        mov     DWORD PTR [gc+fifoRoom], edx
 00000110  89 5C 24 20		          mov     DWORD PTR [esp+_count], vertexCount
				  
 00000114  89 8E 00000DE4	        mov     DWORD PTR [gc+fifoPtr], fifo
 0000011A  85 DB		          test    vertexCount, vertexCount
				  
 0000011C  C7 44 24 14		        mov     DWORD PTR [esp+_pktype], 16 ; 00000010H
	   00000010
 00000124  0F 8F FFFFFF26	          jg      window_coords_begin
				
 0000012A			strip_done:
 0000012A  5D			        pop     ebp
 0000012B  5B			          pop     ebx
 0000012C  5F			        pop     edi
 0000012D  5E			          pop     esi
 0000012E  C2 0014		        ret     20                      ; 00000014H
				
 00000131			__drawvertexlist@20 ENDP
				
 = 00000014			_pktype = 20
 = 00000018			_type = 24
 = 0000001C			_mode = 28
 = 00000020			_count = 32
 = 00000024			_pointers = 36
				
 = esi				gc                 TEXTEQU     <esi>       ; points to graphics context
 = ecx				fifo               TEXTEQU     <ecx>       ; points to next entry in fifo
 = edx				vertexPtr          TEXTEQU     <edx>       ; pointer to vertex or vertex array
				
				        ALIGN 32    
				
				        PUBLIC __vpdrawvertexlist@20
 00000140			__vpdrawvertexlist@20 PROC NEAR
				
 00000140  64: A1		        mov     eax, DWORD PTR fs:  [18h]   ; tls base pointer
	   00000018
 00000146  56			        push    esi
				
 00000147  8B 35 00000008 E	        mov     esi, [__GlideRoot + tlsOffset]; gc position relative to tls base
 0000014D  57			        push    edi
				
 0000014E  53			        push    ebx        
 0000014F  8B 34 06		        mov     gc, [eax + esi]
				        
 00000152  55			        push    ebp
 00000153  8B 4C 24 1C		        mov     ecx, DWORD PTR [esp+_mode]
				        
 00000157  8B 7C 24 24		        mov     edi, DWORD PTR [esp+_pointers]
 0000015B  8B 86 00000B20	        mov     eax, DWORD PTR [gc+wInfo_offset]
				    
 00000161  85 C9		        test    ecx, ecx
 00000163  74 03		        je      w_no_dref
				    
 00000165  8B 3F		        mov     edi, DWORD PTR [edi]
				        
				        align   4
 00000168			w_no_dref:
				        
				;;;     load first w
				        
 00000168  D9 04 38		        fld     DWORD PTR [edi+eax]
 0000016B  D8 3D 00000000 R	        fdivr   DWORD PTR _F1
				        
 00000171  8B 8E 00000B70	        mov     ecx, DWORD PTR [gc+vertexSize]
 00000177  8B 54 24 1C		        mov     edx, DWORD PTR [esp+_mode]
				
 0000017B  8B 7C 24 20		        mov     edi, DWORD PTR [esp+_count]
				;;;     mov     vertexArray, DWORD PTR [esp+_pointers]
				
 0000017F  C1 E2 02		        shl     edx, 2
 00000182  89 0D 00000000 R	        mov     DWORD PTR vSize, ecx
				
 00000188  85 D2		        test    edx, edx
				
 0000018A  75 0C		        jne     SHORT no_stride
				
 0000018C  8B 96 00000B6C	        mov     edx, DWORD PTR [gc+vertexStride]
 00000192  C1 E2 02		        shl     edx, 2
				
				        align 4
 00000198			no_stride:
				
 00000198  89 15 0000000C R	        mov     DWORD PTR strideinbytes, edx
 0000019E  8B 44 24 18		        mov     eax, DWORD PTR [esp+_type]
				
 000001A2  C1 E0 10		        shl     eax, 16                 ; 00000010H
 000001A5  A3 00000008 R	        mov     DWORD PTR packetVal, eax
				
 000001AA			clip_coords_begin:
				
 000001AA  83 FF 0F		        cmp     edi, 15
 000001AD  7C 05		        jl      SHORT clip_partial_packet
 000001AF  BF 0000000F		        mov     edi, 15
 000001B4			clip_partial_packet:
				
				;;;     GR_SET_EXPECTED_SIZE(vcount * vSize, 1)
				
 000001B4  A1 00000000 R	        mov     eax, DWORD PTR vSize
 000001B9  8B 8E 00000DEC	        mov     ecx, DWORD PTR [gc+fifoRoom]
				        
 000001BF  0F AF C7		        imul    eax, edi
 000001C2  83 C0 04		        add     eax, 4
 000001C5  3B C8		        cmp     ecx, eax
 000001C7  7D 0F		        jge     SHORT clip_strip_begin
 000001C9  68 000009D1		        push    @Line
 000001CE  6A 00		        push    0h
 000001D0  50			        push    eax
 000001D1  E8 00000000 E	        call    __grCommandTransportMakeRoom@12
				
				            align 4
 000001D8			clip_strip_begin:
				;;;     TRI_STRIP_BEGIN(type, vcount, vSize, pktype)
				
				  
 000001D8  8B 8E 00000DE4	        mov     fifo, DWORD PTR [gc+fifoPtr]
 000001DE  8B C7		        mov     eax, edi
				        
 000001E0  8B 15 00000008 R	        mov     edx, DWORD PTR packetVal
 000001E6  8B AE 00000DDC	        mov     ebp, DWORD PTR [gc+cullStripHdr]
				        
 000001EC  0B C2		        or      eax, edx
 000001EE  83 C1 04		        add     fifo, 4
				        
 000001F1  C1 E0 06		        shl     eax, 6
 000001F4  8B 54 24 14		        mov     edx, DWORD PTR [esp+_pktype]
				        
 000001F8  0B C5		        or      eax, ebp
				
 000001FA  0B C2		        or      eax, edx
 000001FC  89 41 FC		        mov     DWORD PTR [fifo-4], eax
				
				  
 000001FF  8B 54 24 24		        mov     vertexPtr, DWORD PTR [esp+_pointers]
 00000203  8B 44 24 1C		        mov     eax, DWORD PTR [esp+_mode]
				
 00000207  85 C0		        test    eax, eax
				        
 00000209  74 05		        je      SHORT clip_for_begin
 0000020B  8B 12		        mov     vertexPtr, DWORD PTR [vertexPtr]
				
				        align   4
 00000210			clip_for_begin:
				
 00000210  83 C1 08		        add     fifo, 8
 00000213  8B 2D 0000000C R	        mov     ebp, DWORD PTR strideinbytes
				
 00000219  01 6C 24 24		        add     DWORD PTR [esp+_pointers], ebp
 0000021D  8B 86 000001E4	        mov     eax, DWORD PTR [gc+paramIndex]
				        
 00000223  33 ED		        xor     ebp, ebp
 00000225  8B 9E 00000124	        mov     ebx, DWORD PTR [gc+tsuDataList]
				
				;;; ;   setup x and y
				
 0000022B  D9 86 00000B00	        fld     DWORD PTR [gc+vp_hwidth]
 00000231  D8 0A		        fmul    DWORD PTR [vertexPtr]
 00000233  D8 C9		        fmul    st, st(1)
 00000235  D8 86 00000AF4	        fadd    DWORD PTR [gc+vp_ox]
 0000023B  D9 C9		        fxch    st(1)
				
 0000023D  D9 86 00000B04	        fld     DWORD PTR [gc+vp_hheight]
 00000243  D8 4A 04		        fmul    DWORD PTR [vertexPtr+4]
 00000246  A8 03		        test    al, 3
 00000248  D8 C9		        fmul    st, st(1)
 0000024A  D8 86 00000AF8	        fadd    DWORD PTR [gc+vp_oy]
 00000250  D9 C9		        fxch    st(1)
 00000252  D9 1D 00000004 R	        fstp    DWORD PTR ccoow
 00000258  D9 C9		        fxch    st(1)
 0000025A  D9 59 F8		        fstp    DWORD PTR [fifo-8]
 0000025D  D9 59 FC		        fstp    DWORD PTR [fifo-4]
				        
				;;; ;   set up color
				
 00000260  74 7A		        je      clip_setup_ooz
				  
 00000262  39 AE 00000B74	        cmp     DWORD PTR [gc+colorType], ebp
 00000268  75 5A		        jne     SHORT clip_setup_pargb
				  
 0000026A  A8 01		        test    al, 1
 0000026C  74 36		        je      SHORT clip_setup_a
				        
 0000026E  83 C1 0C		        add     fifo, 12
 00000271  BD 00000003		        mov     ebp, 3
				
 00000276  D9 05 0000002C E	        fld     DWORD PTR __GlideRoot+pool_f255
 0000027C  D8 0C 1A		        fmul    DWORD PTR [ebx+vertexPtr]
 0000027F  D9 05 0000002C E	        fld     DWORD PTR __GlideRoot+pool_f255
 00000285  D8 4C 1A 04		        fmul    DWORD PTR [ebx+vertexPtr+4]
 00000289  D9 05 0000002C E	        fld     DWORD PTR __GlideRoot+pool_f255
 0000028F  D8 4C 1A 08		        fmul    DWORD PTR [ebx+vertexPtr+8]
 00000293  D9 CA		        fxch    st(2)
 00000295  D9 59 F4		        fstp    DWORD PTR [fifo-12]
 00000298  D9 59 F8		        fstp    DWORD PTR [fifo-8]
 0000029B  D9 59 FC		        fstp    DWORD PTR [fifo-4]
 0000029E  8B 9E 00000130	        mov     ebx, DWORD PTR [gc+tsuDataList+12]
				        
				        align 4
 000002A4			clip_setup_a:
				  
 000002A4  A8 02		        test    al, 2
 000002A6  74 34		        je      SHORT clip_setup_ooz
				
 000002A8  83 C1 04		        add     fifo, 4
 000002AB  45			        inc     ebp
				
 000002AC  D9 04 1A		        fld     DWORD PTR [ebx+vertexPtr]  
 000002AF  D8 0D 0000002C E	        fmul    DWORD PTR __GlideRoot+pool_f255
 000002B5  D9 59 FC		        fstp    DWORD PTR [fifo-4]
				  
 000002B8  8B 9C AE		        mov     ebx, DWORD PTR [gc+ebp*4+tsuDataList]
	   00000124
 000002BF  EB 1B		        jmp     SHORT clip_setup_ooz
				        
				        align 4
 000002C4			clip_setup_pargb:
 000002C4  83 C1 04		        add     fifo, 4
 000002C7  8B 1C 1A		        mov     ebx, DWORD PTR [ebx+vertexPtr]
				
 000002CA  89 59 FC		        mov     DWORD PTR [fifo-4], ebx
 000002CD  90			        nop
				        
 000002CE  BD 00000001		        mov     ebp, 1  
 000002D3  8B 9E 00000128	        mov     ebx, DWORD PTR [gc+tsuDataList+4]
				        align 4
 000002DC			clip_setup_ooz:
				  
 000002DC  A8 04		        test    al, 4
 000002DE  74 78		        je      SHORT clip_setup_qow
				
 000002E0  83 C1 04		        add     fifo, 4
 000002E3  45			        inc     ebp
				
 000002E4  F7 86 00000210	        test    DWORD PTR [gc+fbi_fbzMode], 200000h
	   00200000
 000002EE  74 48		        je      clip_setup_ooz_nofog
				
 000002F0  8B 9E 00000B54	        mov     ebx, DWORD PTR [gc+qInfo_mode]
 000002F6  85 DB		        test    ebx, ebx
 000002F8  74 1E		        je      SHORT clip_setup_fog_oow
 000002FA  8B 9E 00000B58	        mov     ebx, DWORD PTR [gc+qInfo_offset]
				
 00000300  D9 04 13		        fld     DWORD PTR [vertexPtr+ebx]
 00000303  D8 0D 00000004 R	        fmul    DWORD PTR ccoow
 00000309  D9 59 FC		        fstp    DWORD PTR [fifo-4]
				        
 0000030C  8B 9C AE		        mov     ebx, DWORD PTR [gc+ebp*4+tsuDataList]
	   00000124
 00000313  EB 43		        jmp     clip_setup_qow
				
				        align 4
 00000318			clip_setup_fog_oow:
				
 00000318  D9 05 00000000 R	        fld     DWORD PTR _F1
 0000031E  D8 25 00000004 R	        fsub    DWORD PTR ccoow
 00000324  D8 8E 00000A44	        fmul    DWORD PTR [gc+depth_range]
 0000032A  D9 59 FC		        fstp    DWORD PTR [fifo-4]
				
 0000032D  8B 9C AE		        mov     ebx, DWORD PTR [gc+ebp*4+tsuDataList]
	   00000124
 00000334  EB 22		        jmp     clip_setup_qow
				
				        align 4
 00000338			clip_setup_ooz_nofog:   
				        
 00000338  D9 04 1A		        fld     DWORD PTR [ebx+vertexPtr]  
 0000033B  D8 8E 00000B08	        fmul    DWORD PTR [gc+vp_hdepth]
 00000341  D8 0D 00000004 R	        fmul    DWORD PTR ccoow  
 00000347  D8 86 00000AFC	        fadd    DWORD PTR [gc+vp_oz]
 0000034D  D9 59 FC		        fstp    DWORD PTR [fifo-4]
				  
 00000350  8B 9C AE		        mov     ebx, DWORD PTR [gc+ebp*4+tsuDataList]
	   00000124
				        align 4
 00000358			clip_setup_qow:
				  
 00000358  A8 08		        test    al, 8
 0000035A  74 54		        je      SHORT clip_setup_qow0
				  
 0000035C  8B 9E 00000B2C	        mov     ebx, DWORD PTR [gc+fogInfo_mode]
 00000362  85 DB		        test    ebx, ebx
 00000364  74 16		        je      SHORT clip_setup_oow_nofog
 00000366  8B 9E 00000B30	        mov     ebx, DWORD PTR [gc+fogInfo_offset]
				
 0000036C  D9 04 13		        fld     DWORD PTR [vertexPtr+ebx]
 0000036F  D8 0D 00000004 R	        fmul    DWORD PTR ccoow
 00000375  D9 19		        fstp    DWORD PTR [fifo]
				
 00000377  EB 2B		        jmp     SHORT clip_setup_oow_inc
				        
				        align 4
 0000037C			clip_setup_oow_nofog:
				        
 0000037C  8B 9E 00000B54	        mov     ebx, DWORD PTR [gc+qInfo_mode]
 00000382  85 DB		        test    ebx, ebx
 00000384  74 16		        je      SHORT clip_setup_oow
 00000386  8B 9E 00000B58	        mov     ebx, DWORD PTR [gc+qInfo_offset]
				
 0000038C  D9 04 13		        fld     DWORD PTR [vertexPtr+ebx]
 0000038F  D8 0D 00000004 R	        fmul    DWORD PTR ccoow
 00000395  D9 19		        fstp    DWORD PTR [fifo]
				
 00000397  EB 0B		        jmp     SHORT clip_setup_oow_inc
				        
				        align 4
 0000039C			clip_setup_oow:
 0000039C  8B 1D 00000004 R	        mov     ebx, DWORD PTR ccoow
				
 000003A2  89 19		        mov     DWORD PTR [fifo], ebx
				        align 4
 000003A4			clip_setup_oow_inc:
				  
 000003A4  8B 9C AE		        mov     ebx, DWORD PTR [gc+ebp*4+tsuDataList+4]
	   00000128
 000003AB  83 C1 04		        add     fifo, 4
				        
 000003AE  45			        inc     ebp
				        align 4
 000003B0			clip_setup_qow0:
				  
 000003B0  A8 10		        test    al, 16
 000003B2  74 34		        je      SHORT clip_setup_stow0
				  
 000003B4  8B 9E 00000B5C	        mov     ebx, DWORD PTR [gc+q0Info_mode]
 000003BA  83 FB 01		        cmp     ebx, 1
 000003BD  75 15		        jne     SHORT clip_setup_oow0
				  
 000003BF  8B 9E 00000B60	        mov     ebx, DWORD PTR [gc+q0Info_offset]
				        
 000003C5  D9 04 1A		        fld     DWORD PTR [ebx+vertexPtr]
 000003C8  D8 0D 00000004 R	        fmul    DWORD PTR ccoow
 000003CE  D9 19		        fstp    DWORD PTR [fifo]
				        
 000003D0  EB 0A		        jmp     SHORT clip_setup_oow0_inc
				        align 4
 000003D4			clip_setup_oow0:
 000003D4  8B 1D 00000004 R	        mov     ebx, DWORD PTR ccoow
				        
 000003DA  89 19		        mov     DWORD PTR [fifo], ebx
				        align 4
 000003DC			clip_setup_oow0_inc:
 000003DC  8B 9C AE		        mov     ebx, DWORD PTR [gc+ebp*4+tsuDataList+4]
	   00000128
 000003E3  83 C1 04		        add     fifo, 4
				        
 000003E6  45			        inc     ebp
				        align 4
 000003E8			clip_setup_stow0:
				  
 000003E8  A8 20		        test    al, 32
 000003EA  74 34		        je      SHORT clip_setup_qow1
				        
				
 000003EC  D9 05 00000004 R	        fld     DWORD PTR ccoow
 000003F2  D8 0C 1A		        fmul    DWORD PTR [ebx+vertexPtr]
				
 000003F5  83 C1 08		        add     fifo, 8
 000003F8  83 C5 02		        add     ebp, 2
				
 000003FB  D8 8E 00000A0C	        fmul    DWORD PTR [gc+tmu0_s_scale]
 00000401  D9 05 00000004 R	        fld     DWORD PTR ccoow
 00000407  D8 4C 1A 04		        fmul    DWORD PTR [ebx+vertexPtr+4]
 0000040B  8B 9C AE		        mov     ebx, DWORD PTR [gc+ebp*4+tsuDataList]
	   00000124
 00000412  D8 8E 00000A10	        fmul    DWORD PTR [gc+tmu0_t_scale]
 00000418  D9 C9		        fxch
 0000041A  D9 59 F8		        fstp    DWORD PTR [fifo-8]
 0000041D  D9 59 FC		        fstp    DWORD PTR [fifo-4]
				        
				        align 4
 00000420			clip_setup_qow1:
				
 00000420  A8 40		        test    al, 64
 00000422  74 34		        je      SHORT clip_setup_stow1
				
 00000424  8B 9E 00000B64	        mov     ebx, DWORD PTR [gc+q1Info_mode]
 0000042A  83 FB 01		        cmp     ebx, 1
 0000042D  75 15		        jne     SHORT clip_setup_oow1
				
 0000042F  8B 9E 00000B68	        mov     ebx, DWORD PTR [gc+q1Info_offset]
				        
 00000435  D9 04 1A		        fld     DWORD PTR [ebx+vertexPtr]
 00000438  D8 0D 00000004 R	        fmul    DWORD PTR ccoow
 0000043E  D9 19		        fstp    DWORD PTR [fifo]
				        
 00000440  EB 0A		        jmp     SHORT clip_setup_oow1_inc
				        align 4
 00000444			clip_setup_oow1:
 00000444  8B 1D 00000004 R	        mov     ebx, DWORD PTR ccoow
				
 0000044A  89 19		        mov     DWORD PTR [fifo], ebx
				        align 4
 0000044C			clip_setup_oow1_inc:
				  
 0000044C  8B 9C AE		        mov     ebx, DWORD PTR [gc+ebp*4+tsuDataList+4]
	   00000128
 00000453  83 C1 04		        add     fifo, 4
				
 00000456  45			        inc     ebp
				
				        align 4
 00000458			clip_setup_stow1:
				  
 00000458  A8 80		        test    al, 128
 0000045A  74 34		        je      SHORT clip_setup_end
				
 0000045C  D9 05 00000004 R	        fld     DWORD PTR ccoow
 00000462  D8 0C 1A		        fmul    DWORD PTR [ebx+vertexPtr]
 00000465  83 C1 08		        add     fifo, 8
 00000468  D8 8E 00000A28	        fmul    DWORD PTR [gc+tmu1_s_scale]
 0000046E  D9 05 00000004 R	        fld     DWORD PTR ccoow
 00000474  D8 4C 1A 04		        fmul    DWORD PTR [ebx+vertexPtr+4]
 00000478  8B 9C AE		        mov     ebx, DWORD PTR [gc+ebp*4+tsuDataList+4]
	   00000128
 0000047F  D8 8E 00000A2C	        fmul    DWORD PTR [gc+tmu1_t_scale]
 00000485  D9 C9		        fxch        
 00000487  D9 59 F8		        fstp    DWORD PTR [fifo-8]
 0000048A  D9 59 FC		        fstp    DWORD PTR [fifo-4]
				
				        align 4
 00000490			clip_setup_end:
				
 00000490  4F			        dec     edi        
 00000491  74 25		        jz      clip_for_end
				
 00000493  8B 54 24 24		        mov     vertexPtr, DWORD PTR [esp+_pointers]
 00000497  8B 5C 24 1C		        mov     ebx, DWORD PTR [esp+_mode]
				
 0000049B  85 DB		        test    ebx, ebx
 0000049D  74 05		        je      SHORT w_clip_no_deref
				
				
 0000049F  8B 12		        mov     vertexPtr, DWORD PTR [vertexPtr]
				        align 4
 000004A4			w_clip_no_deref:
				
 000004A4  8B 9E 00000B20	        mov     ebx, DWORD PTR [gc+wInfo_offset]
				        
 000004AA  D9 04 1A		        fld     DWORD PTR [ebx+vertexPtr]  
 000004AD  D8 3D 00000000 R	        fdivr   DWORD PTR _F1
				        
 000004B3  E9 FFFFFD58		        jmp     clip_for_begin
				        align 4
 000004B8			clip_for_end:
				  
 000004B8  8B 9E 00000DE4	        mov     ebx, DWORD PTR [gc+fifoPtr]
 000004BE  8B 96 00000DEC	        mov     edx, DWORD PTR [gc+fifoRoom]
				        
 000004C4  2B D9		        sub     ebx, fifo
 000004C6  8B 7C 24 20		        mov     edi, DWORD PTR [esp+_count]
				        
 000004CA  03 D3		        add     edx, ebx
 000004CC  83 EF 0F		        sub     edi, 15                 ; 0000000fH
				  
 000004CF  89 96 00000DEC	        mov     DWORD PTR [gc+fifoRoom], edx
 000004D5  89 7C 24 20		        mov     DWORD PTR [esp+_count], edi
				  
 000004D9  89 8E 00000DE4	        mov     DWORD PTR [gc+fifoPtr], fifo
 000004DF  C7 44 24 14		        mov     DWORD PTR [esp+_pktype], 16 ; 00000010H
	   00000010
				
 000004E7  7E 23		        jle     strip_done
 000004E9  8B 54 24 24		        mov     edx, DWORD PTR [esp+_pointers]
				
 000004ED  8B 5C 24 1C		        mov     ebx, DWORD PTR [esp+_mode]
 000004F1  85 DB		        test    ebx, ebx
				        
 000004F3  74 03		        je      SHORT w1_clip_no_deref
 000004F5  8B 12		        mov     edx, DWORD PTR [edx]
				        
				        align 4
 000004F8			w1_clip_no_deref:
				
 000004F8  8B 9E 00000B20	        mov     ebx, DWORD PTR [gc+wInfo_offset]
 000004FE  D9 04 1A		        fld     DWORD PTR [ebx+edx]  
 00000501  D8 3D 00000000 R	        fdivr   DWORD PTR _F1
				  
 00000507  E9 FFFFFC9E		        jmp     clip_coords_begin
				        align 4
 0000050C			strip_done:
				
 0000050C  5D			        pop     ebp
 0000050D  5B			        pop     ebx
				    
 0000050E  5F			        pop     edi
 0000050F  5E			        pop     esi
				    
 00000510  C2 0014		        ret     20                      ; 00000014H
 00000513			__vpdrawvertexlist@20 ENDP
				
 = esi				gc                 TEXTEQU     <esi>       ; points to graphics context
 = ecx				fifo               TEXTEQU     <ecx>       ; points to next entry in fifo
 = edi				vertexPtr          TEXTEQU     <edi>       ; Current vertex pointer
				
				    ;; NB:  All of the base triangle procs expect to have the gc
				    ;;      passed from the caller in edx so that we can avoid
				    ;;      the agi from the far pointer. Screw w/ this at your
				    ;;      own peril.
				    ;;
				    ;;      YOU HAVE BEEN WARNED        
				
				        ALIGN 32    
				
				    PUBLIC  __vptrisetup_cull@12
 00000520			__vptrisetup_cull@12 PROC NEAR
 = 00000014			_va = 20
 = 00000018			_vb = 24
 = 0000001C			_vc = 28
 00000520  53			        push    ebx
 00000521  56			        push    esi
				        
 00000522  57			        push    edi
 00000523  8B F2		        mov     gc, edx
				
				        ;
				        ; AJB: Clip Coord mode needs to call grValidateState
				        ;
 00000525  8B 96 00000B78	        mov       edx, [gc + invalid]        ; state needs validation ?
				
 0000052B  85 D2		        test      edx, edx                   ; do we need to validate state ?
 0000052D  74 05		        je        $no_validation             ; nope, it's valid
				
 0000052F  E8 00000000 E	        call      __grValidateState          ; validate state
				
 00000534			$no_validation:
				        
 00000534  8B 4C 24 10		        mov     ecx, DWORD PTR [esp+_va-4]
 00000538  8B 86 00000B20	        mov     eax, DWORD PTR [gc+wInfo_offset]
				        
 0000053E  55			        push    ebp
 0000053F  90			        nop
				        
				;;; ;   oow[0] = 1.0f / FARRAY(va, gc->state.vData.wInfo.offset)
				
 00000540  D9 04 01		        fld     DWORD PTR [eax+ecx]
				
 00000543  D8 3D 00000000 R	        fdivr   DWORD PTR _F1
				
 00000549  8B 4C 24 18		        mov     ecx, DWORD PTR [esp+_vb]
 0000054D  8B 5C 24 1C		        mov     ebx, DWORD PTR [esp+_vc]
				
 00000551  90			        nop
 00000552  90			        nop
				        
 00000553  8B 2C 01		        mov     ebp, DWORD PTR [eax+ecx]
 00000556  8B 3C 03		        mov     edi, DWORD PTR [eax+ebx]
				
 00000559  89 2D 00000018 R	        mov     DWORD PTR vPtr1, ebp
 0000055F  89 3D 0000001C R	        mov     DWORD PTR vPtr2, edi
				        
				;;; ;   GR_SET_EXPECTED_SIZE(_GlideRoot.curTriSize, 1)
				
 00000565  8B 46 4C		        mov     eax, DWORD PTR [gc+curTriSize]
 00000568  8B 8E 00000DEC	        mov     ecx, DWORD PTR [gc+fifoRoom]
				        
 0000056E  83 C0 04		        add     eax, 4
 00000571  90			        nop
				        
 00000572  3B C8		        cmp     ecx, eax
 00000574  7D 0E		        jge     SHORT setup_pkt_hdr
				        
 00000576  68 00000B8E		        push    @Line                      ; line number inside this function
 0000057B  6A 00		        push    0h                         ; pointer to function name = NULL
				
 0000057D  50			        push    eax
 0000057E  E8 00000000 E	        call    __grCommandTransportMakeRoom@12
				
				        align 4
 00000584			setup_pkt_hdr:  
				
				;;; ;   TRI_STRIP_BEGIN(kSetupStrip, 3, gc->state.vData.vSize, SSTCP_PKT3_BDDBDD)
				
				
 00000584  8B 8E 00000DE4	        mov     fifo, DWORD PTR [gc+fifoPtr]
 0000058A  8B 86 00000DDC	        mov     eax, DWORD PTR [gc+cullStripHdr]
				
 00000590  83 C1 04		        add     fifo, 4
 00000593  8D 6C 24 14		        lea     ebp, DWORD PTR [esp+_va]
				
 00000597  0D 000000C0		        or      eax, 192                ; 000000c0H
 0000059C  BA 00000000		        mov     edx, 0                
				
 000005A1  89 41 FC		        mov     DWORD PTR [fifo-4], eax        
 000005A4  8B 7D 00		        mov     vertexPtr, DWORD PTR [ebp]
				
 000005A7  8B 86 000001E4	        mov     eax, DWORD PTR [gc+paramIndex]
 000005AD  90			        nop
				
				;;; Begin loop
				        
				        align 4
 000005B0			begin_for_loop:
				
 000005B0  83 C2 04		        add     edx, 4
 000005B3  83 C1 08		        add     fifo, 8
				        
 000005B6  33 DB		        xor     ebx, ebx
 000005B8  8B AE 00000124	        mov     ebp, DWORD PTR [gc+tsuDataList]
				
				;;; ;   setup x and y
				
 000005BE  D9 86 00000B00	        fld     DWORD PTR [gc+vp_hwidth]
 000005C4  D8 0F		        fmul    DWORD PTR [vertexPtr]
 000005C6  D8 C9		        fmul    st, st(1)
 000005C8  D8 86 00000AF4	        fadd    DWORD PTR [gc+vp_ox]
 000005CE  D9 C9		        fxch    st(1)
				
 000005D0  D9 47 04		        fld     DWORD PTR [vertexPtr+4]
 000005D3  D8 8E 00000B04	        fmul    DWORD PTR [gc+vp_hheight]
 000005D9  A8 03		        test    al, 3
 000005DB  D8 C9		        fmul    st, st(1)
 000005DD  D8 86 00000AF8	        fadd    DWORD PTR [gc+vp_oy]
 000005E3  D9 C9		        fxch    st(1)
 000005E5  D9 1D 00000010 R	        fstp    DWORD PTR oowa    
 000005EB  D9 C9		        fxch    st(1)
 000005ED  D9 59 F8		        fstp    DWORD PTR [fifo-8]
 000005F0  D9 59 FC		        fstp    DWORD PTR [fifo-4]
				        
				;;; ;   set up color
				
 000005F3  74 7B		        je      clip_setup_ooz
				
 000005F5  39 9E 00000B74	        cmp     DWORD PTR [gc+colorType], ebx
 000005FB  75 5B		        jne     SHORT clip_setup_pargb
				        
 000005FD  A8 01		        test    al, 1
 000005FF  74 37		        je      SHORT clip_setup_a
				
 00000601  83 C1 0C		        add     fifo, 12
 00000604  83 C3 03		        add     ebx, 3
				
 00000607  D9 05 0000002C E	        fld     DWORD PTR __GlideRoot+pool_f255
 0000060D  D8 4C 3D 00		        fmul    DWORD PTR [vertexPtr+ebp]
 00000611  D9 05 0000002C E	        fld     DWORD PTR __GlideRoot+pool_f255
 00000617  D8 4C 3D 04		        fmul    DWORD PTR [vertexPtr+ebp+4]
 0000061B  D9 05 0000002C E	        fld     DWORD PTR __GlideRoot+pool_f255
 00000621  D8 4C 3D 08		        fmul    DWORD PTR [vertexPtr+ebp+8]
 00000625  D9 CA		        fxch    st(2)
 00000627  D9 59 F4		        fstp    DWORD PTR [fifo-12]
 0000062A  D9 59 F8		        fstp    DWORD PTR [fifo-8]
 0000062D  D9 59 FC		        fstp    DWORD PTR [fifo-4]
 00000630  8B AE 00000130	        mov     ebp, DWORD PTR [gc+tsuDataList+12]
				        
				        align 4
 00000638			clip_setup_a:          
				
 00000638  A8 02		        test    al, 2
 0000063A  74 34		        je      SHORT clip_setup_ooz
				        
 0000063C  83 C1 04		        add     fifo, 4
 0000063F  43			        inc     ebx
				        
 00000640  D9 44 3D 00		        fld     DWORD PTR [vertexPtr+ebp]
 00000644  D8 0D 0000002C E	        fmul    DWORD PTR __GlideRoot+pool_f255
 0000064A  D9 59 FC		        fstp    DWORD PTR [fifo-4]
				        
 0000064D  8B AC 9E		        mov     ebp, DWORD PTR [gc+tsuDataList+ebx*4]
	   00000124
 00000654  EB 1A		        jmp     SHORT clip_setup_ooz
				        align 4
 00000658			clip_setup_pargb:
 00000658  83 C1 04		        add     fifo, 4
 0000065B  8B 5C 3D 00		        mov     ebx, DWORD PTR [vertexPtr+ebp]
				        
 0000065F  89 59 FC		        mov     DWORD PTR [fifo-4], ebx
 00000662  90			        nop
				        
 00000663  BB 00000001		        mov     ebx, 1
 00000668  8B AE 00000128	        mov     ebp, DWORD PTR [gc+tsuDataList+4]
				        align 4
 00000670			clip_setup_ooz:
				
 00000670  A8 04		        test    al, 4
 00000672  74 78		        je      SHORT clip_setup_qow
				        
 00000674  83 C1 04		        add     fifo, 4
 00000677  43			        inc     ebx
				        
 00000678  F7 86 00000210	        test    DWORD PTR [gc+fbi_fbzMode], 200000h
	   00200000
 00000682  74 48		        je      clip_setup_ooz_nofog
				
 00000684  8B AE 00000B54	        mov     ebp, DWORD PTR [gc+qInfo_mode]
 0000068A  85 ED		        test    ebp, ebp
 0000068C  74 1E		        je      SHORT clip_setup_fog_oow
 0000068E  8B AE 00000B58	        mov     ebp, DWORD PTR [gc+qInfo_offset]
				
 00000694  D9 44 3D 00		        fld     DWORD PTR [vertexPtr+ebp]
 00000698  D8 0D 00000010 R	        fmul    DWORD PTR oowa
 0000069E  D9 59 FC		        fstp    DWORD PTR [fifo-4]
				
 000006A1  8B AC 9E		        mov     ebp, DWORD PTR [gc+tsuDataList+ebx*4]
	   00000124
 000006A8  EB 42		        jmp     clip_setup_qow
				
				        align 4
 000006AC			clip_setup_fog_oow:
				
 000006AC  D9 05 00000000 R	        fld     DWORD PTR _F1
 000006B2  D8 25 00000010 R	        fsub    DWORD PTR oowa
 000006B8  D8 8E 00000A44	        fmul    DWORD PTR [gc+depth_range]
 000006BE  D9 59 FC		        fstp    DWORD PTR [fifo-4]
				
 000006C1  8B AC 9E		        mov     ebp, DWORD PTR [gc+tsuDataList+ebx*4]
	   00000124
 000006C8  EB 22		        jmp     clip_setup_qow
				
				        align 4
 000006CC			clip_setup_ooz_nofog:   
				
 000006CC  D9 44 3D 00		        fld     DWORD PTR [vertexPtr+ebp]
 000006D0  D8 8E 00000B08	        fmul    DWORD PTR [gc+vp_hdepth]
 000006D6  D8 0D 00000010 R	        fmul    DWORD PTR oowa
 000006DC  D8 86 00000AFC	        fadd    DWORD PTR [gc+vp_oz]
 000006E2  D9 59 FC		        fstp    DWORD PTR [fifo-4]
				        
 000006E5  8B AC 9E		        mov     ebp, DWORD PTR [gc+tsuDataList+ebx*4]
	   00000124
				        align 4
 000006EC			clip_setup_qow: 
				
 000006EC  A8 08		        test    al, 8
 000006EE  74 4C		        je      SHORT clip_setup_qow0
				
 000006F0  83 BE 00000B2C	        cmp     DWORD PTR [gc+fogInfo_mode], 1
	   01
 000006F7  75 13		        jne     SHORT clip_setup_oow_nofog
				
 000006F9  8B AE 00000B30	        mov     ebp, DWORD PTR [gc+fogInfo_offset]
 000006FF  D9 05 00000010 R	        fld     DWORD PTR oowa
 00000705  D8 0C 2F		        fmul    DWORD PTR [ebp+vertexPtr]
 00000708  D9 19		        fstp    DWORD PTR [fifo]
				        
 0000070A  EB 24		        jmp     SHORT clip_setup_oow_inc
				        align 4
 0000070C			clip_setup_oow_nofog:
 0000070C  83 BE 00000B54	        cmp     DWORD PTR [gc+qInfo_mode], 1
	   01
 00000713  75 13		        jne     SHORT clip_setup_oow
				
 00000715  8B AE 00000B58	        mov     ebp, DWORD PTR [gc+qInfo_offset]
 0000071B  D9 05 00000010 R	        fld     DWORD PTR oowa
 00000721  D8 0C 2F		        fmul    DWORD PTR [ebp+vertexPtr]
 00000724  D9 19		        fstp    DWORD PTR [fifo]
				        
 00000726  EB 08		        jmp     SHORT clip_setup_oow_inc
				        align 4
 00000728			clip_setup_oow:
				        
 00000728  8B 2D 00000010 R	        mov     ebp, DWORD PTR oowa
				        
 0000072E  89 29		        mov     DWORD PTR [fifo], ebp
				        align 4
 00000730			clip_setup_oow_inc:
 00000730  8B AC 9E		        mov     ebp, DWORD PTR [gc+tsuDataList+ebx*4+4]   
	   00000128
 00000737  83 C1 04		        add     fifo, 4
				        
 0000073A  43			        inc     ebx
				        align 4
 0000073C			clip_setup_qow0:
				
 0000073C  A8 10		        test    al, 16                  ; 00000010H
 0000073E  74 30		        je      SHORT clip_setup_stow0
				
 00000740  83 BE 00000B5C	        cmp     DWORD PTR [gc+q0Info_mode], 1        
	   01
 00000747  75 13		        jne     SHORT clip_setup_oow0
				                        
 00000749  8B AE 00000B60	        mov     ebp, DWORD PTR [gc+q0Info_offset]
				        
 0000074F  D9 05 00000010 R	        fld     DWORD PTR oowa
 00000755  D8 0C 2F		        fmul    DWORD PTR [ebp+vertexPtr]
 00000758  D9 19		        fstp    DWORD PTR [fifo]
				        
 0000075A  EB 08		        jmp     SHORT clip_setup_oow0_inc
				        align 4
 0000075C			clip_setup_oow0:
 0000075C  8B 2D 00000010 R	        mov     ebp, DWORD PTR oowa
				        
 00000762  89 29		        mov     DWORD PTR [fifo], ebp
				        align 4
 00000764			clip_setup_oow0_inc:
 00000764  8B AC 9E		        mov     ebp, DWORD PTR [gc+tsuDataList+ebx*4+4]
	   00000128
 0000076B  83 C1 04		        add     fifo, 4
				        
 0000076E  43			        inc     ebx
				        align 4
 00000770			clip_setup_stow0:
				                        
 00000770  A8 20		        test    al, 32
 00000772  74 38		        je      SHORT clip_setup_qow1
				
				        
 00000774  D9 05 00000010 R	        fld     DWORD PTR oowa
 0000077A  D8 4C 3D 00		        fmul    DWORD PTR [vertexPtr+ebp]
				
 0000077E  83 C1 08		        add     fifo, 8
 00000781  83 C3 02		        add     ebx, 2
				
 00000784  D8 8E 00000A0C	        fmul    DWORD PTR [gc+tmu0_s_scale]
 0000078A  D9 05 00000010 R	        fld     DWORD PTR oowa
 00000790  D8 4C 3D 04		        fmul    DWORD PTR [vertexPtr+ebp+4]
 00000794  8B AC 9E		        mov     ebp, DWORD PTR [gc+tsuDataList+ebx*4]
	   00000124
 0000079B  D8 8E 00000A10	        fmul    DWORD PTR [gc+tmu0_t_scale]
 000007A1  D9 C9		        fxch    
 000007A3  D9 59 F8		        fstp    DWORD PTR [fifo-8]
 000007A6  D9 59 FC		        fstp    DWORD PTR [fifo-4]
				        
				        align 4
 000007AC			clip_setup_qow1:
				
 000007AC  A8 40		        test    al, 64
 000007AE  74 30		        je      SHORT clip_setup_stow1
				
 000007B0  83 BE 00000B64	        cmp     DWORD PTR [gc+q1Info_mode], 1
	   01
 000007B7  75 13		        jne     SHORT clip_setup_oow1
				
 000007B9  8B AE 00000B68	        mov     ebp, DWORD PTR [gc+q1Info_offset]
				        
 000007BF  D9 04 2F		        fld     DWORD PTR [ebp+vertexPtr]
 000007C2  D8 0D 00000010 R	        fmul    DWORD PTR oowa
 000007C8  D9 19		        fstp    DWORD PTR [fifo]
				        
 000007CA  EB 08		        jmp     SHORT clip_setup_oow1_inc
				        align 4
 000007CC			clip_setup_oow1:
 000007CC  8B 2D 00000010 R	        mov     ebp, DWORD PTR oowa
				        
 000007D2  89 29		        mov     DWORD PTR [fifo], ebp
				        align 4
 000007D4			clip_setup_oow1_inc:
 000007D4  8B AC 9E		        mov     ebp, DWORD PTR [gc+tsuDataList+ebx*4+4]
	   00000128
 000007DB  83 C1 04		        add     fifo, 4
				        
 000007DE  43			        inc     ebx
				        align 4
 000007E0			clip_setup_stow1:
				
 000007E0  A8 80		        test    al, 128
 000007E2  74 2C		        je      SHORT clip_setup_end
				        
				
 000007E4  D9 05 00000010 R	        fld     DWORD PTR oowa
 000007EA  D8 4C 3D 00		        fmul    DWORD PTR [vertexPtr+ebp]
 000007EE  83 C1 08		        add     fifo, 8  
 000007F1  D8 8E 00000A28	        fmul    DWORD PTR [gc+tmu1_s_scale]
 000007F7  D9 05 00000010 R	        fld     DWORD PTR oowa
 000007FD  D8 4C 3D 04		        fmul    DWORD PTR [vertexPtr+ebp+4]
 00000801  D8 8E 00000A2C	        fmul    DWORD PTR [gc+tmu1_t_scale]
 00000807  D9 C9		        fxch    
 00000809  D9 59 F8		        fstp    DWORD PTR [fifo-8]
 0000080C  D9 59 FC		        fstp    DWORD PTR [fifo-4]
				
				        align 4
 00000810			clip_setup_end:
				
 00000810  83 FA 0C		        cmp     edx, 12
 00000813  74 1F		        je      update_fifo_ptr
				        
 00000815  D9 82 00000014 R	        fld     DWORD PTR vPtr0[edx]
 0000081B  D8 3D 00000000 R	        fdivr   DWORD PTR _F1
				        
 00000821  8D 5C 24 14		        lea     ebx, DWORD PTR [esp+_va]
 00000825  8B AE 00000B20	        mov     ebp, DWORD PTR [gc+wInfo_offset]
				        
 0000082B  8B 3C 1A		        mov     vertexPtr, DWORD PTR [ebx+edx]
 0000082E  E9 FFFFFD7D		        jmp     begin_for_loop
				       
				        align 4
 00000834			update_fifo_ptr:        
				
 00000834  8B 9E 00000DE4	        mov     ebx, DWORD PTR [gc+fifoPtr]; Move gcFifo->fifoPtr to ebx
 0000083A  8B 96 00000DEC	        mov     edx, DWORD PTR [gc+fifoRoom]; move gcFifo->fifoRoom to edx
				        
 00000840  2B D9		        sub     ebx, fifo       ; subtract local fifo copy from ebx
				                                ; this yields the negative of what we
				                                ; wrote to the fiof
 00000842  B8 00000001		        mov     eax, 1          ; place a 1 in eax for return
				
 00000847  03 D3		        add     edx, ebx        ; add (now negative) amount written to
				                                ; the fifo to our local copy of the
				                                ; fifoRoom variable 
 00000849  89 96 00000DEC	        mov     DWORD PTR [gc+fifoRoom], edx; move the local fifoRoom
				                                ; back to the gc
				    
 0000084F  89 8E 00000DE4	        mov     DWORD PTR [gc+fifoPtr], fifo; move local fifoPointer
				                                ; back to gc
 00000855  8B 5E 0C		        mov     ebx, DWORD PTR [gc+trisProcessed]; load trisProcessed
				                                ; into register
				
				;;; ;   _GlideRoot.stats.trisProcessed++
 00000858  43			        inc     ebx             ; increment trisProcessed
				
 00000859  89 5E 0C		        mov     DWORD PTR [gc+trisProcessed], ebx; Store trisProcessed
				                                ; back to GC
				    
				   ;; Clean up the stack
 0000085C  5D			        pop     ebp
 0000085D  5E			        pop     esi
				    
 0000085E  5B			        pop     ebx
 0000085F  5F			        pop     edi
				        
 00000860  C2 000C		        ret     12                      ; 0000000cH
				        
 00000863			__vptrisetup_cull@12 ENDP
 0863				_TEXT   ENDS
				    
				endif  ; !GL_AMD3D
				
				END
Microsoft (R) Macro Assembler Version 6.14.8444		    06/30/00 13:01:25
xdraw3.asm						     Symbols 2 - 1




Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

CONST  . . . . . . . . . . . . .	32 Bit	 0010	  Para	  Private 
FLAT . . . . . . . . . . . . . .	GROUP
_DATA  . . . . . . . . . . . . .	32 Bit	 0020	  Para	  Private 
_TEXT  . . . . . . . . . . . . .	32 Bit	 0863	  Page	  Public  'CODE'	


Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

__drawvertexlist@20  . . . . . .	P Near	 0000	  _TEXT	Length= 0131 Public
  no_stride  . . . . . . . . . .	L Near	 003C	  _TEXT	
  window_coords_begin  . . . . .	L Near	 0050	  _TEXT	
  win_partial_packet . . . . . .	L Near	 005C	  _TEXT	
  win_strip_begin  . . . . . . .	L Near	 0080	  _TEXT	
  win_for_begin  . . . . . . . .	L Near	 00AC	  _TEXT	
  win_no_deref . . . . . . . . .	L Near	 00BC	  _TEXT	
  win_datalist_begin . . . . . .	L Near	 00DC	  _TEXT	
  win_datalist_end . . . . . . .	L Near	 00F0	  _TEXT	
  win_for_end  . . . . . . . . .	L Near	 00F3	  _TEXT	
  strip_done . . . . . . . . . .	L Near	 012A	  _TEXT	
__vpdrawvertexlist@20  . . . . .	P Near	 0140	  _TEXT	Length= 03D3 Public
  w_no_dref  . . . . . . . . . .	L Near	 0168	  _TEXT	
  no_stride  . . . . . . . . . .	L Near	 0198	  _TEXT	
  clip_coords_begin  . . . . . .	L Near	 01AA	  _TEXT	
  clip_partial_packet  . . . . .	L Near	 01B4	  _TEXT	
  clip_strip_begin . . . . . . .	L Near	 01D8	  _TEXT	
  clip_for_begin . . . . . . . .	L Near	 0210	  _TEXT	
  clip_setup_a . . . . . . . . .	L Near	 02A4	  _TEXT	
  clip_setup_pargb . . . . . . .	L Near	 02C4	  _TEXT	
  clip_setup_ooz . . . . . . . .	L Near	 02DC	  _TEXT	
  clip_setup_fog_oow . . . . . .	L Near	 0318	  _TEXT	
  clip_setup_ooz_nofog . . . . .	L Near	 0338	  _TEXT	
  clip_setup_qow . . . . . . . .	L Near	 0358	  _TEXT	
  clip_setup_oow_nofog . . . . .	L Near	 037C	  _TEXT	
  clip_setup_oow . . . . . . . .	L Near	 039C	  _TEXT	
  clip_setup_oow_inc . . . . . .	L Near	 03A4	  _TEXT	
  clip_setup_qow0  . . . . . . .	L Near	 03B0	  _TEXT	
  clip_setup_oow0  . . . . . . .	L Near	 03D4	  _TEXT	
  clip_setup_oow0_inc  . . . . .	L Near	 03DC	  _TEXT	
  clip_setup_stow0 . . . . . . .	L Near	 03E8	  _TEXT	
  clip_setup_qow1  . . . . . . .	L Near	 0420	  _TEXT	
  clip_setup_oow1  . . . . . . .	L Near	 0444	  _TEXT	
  clip_setup_oow1_inc  . . . . .	L Near	 044C	  _TEXT	
  clip_setup_stow1 . . . . . . .	L Near	 0458	  _TEXT	
  clip_setup_end . . . . . . . .	L Near	 0490	  _TEXT	
  w_clip_no_deref  . . . . . . .	L Near	 04A4	  _TEXT	
  clip_for_end . . . . . . . . .	L Near	 04B8	  _TEXT	
  w1_clip_no_deref . . . . . . .	L Near	 04F8	  _TEXT	
  strip_done . . . . . . . . . .	L Near	 050C	  _TEXT	
__vptrisetup_cull@12 . . . . . .	P Near	 0520	  _TEXT	Length= 0343 Public
  $no_validation . . . . . . . .	L Near	 0534	  _TEXT	
  setup_pkt_hdr  . . . . . . . .	L Near	 0584	  _TEXT	
  begin_for_loop . . . . . . . .	L Near	 05B0	  _TEXT	
  clip_setup_a . . . . . . . . .	L Near	 0638	  _TEXT	
  clip_setup_pargb . . . . . . .	L Near	 0658	  _TEXT	
  clip_setup_ooz . . . . . . . .	L Near	 0670	  _TEXT	
  clip_setup_fog_oow . . . . . .	L Near	 06AC	  _TEXT	
  clip_setup_ooz_nofog . . . . .	L Near	 06CC	  _TEXT	
  clip_setup_qow . . . . . . . .	L Near	 06EC	  _TEXT	
  clip_setup_oow_nofog . . . . .	L Near	 070C	  _TEXT	
  clip_setup_oow . . . . . . . .	L Near	 0728	  _TEXT	
  clip_setup_oow_inc . . . . . .	L Near	 0730	  _TEXT	
  clip_setup_qow0  . . . . . . .	L Near	 073C	  _TEXT	
  clip_setup_oow0  . . . . . . .	L Near	 075C	  _TEXT	
  clip_setup_oow0_inc  . . . . .	L Near	 0764	  _TEXT	
  clip_setup_stow0 . . . . . . .	L Near	 0770	  _TEXT	
  clip_setup_qow1  . . . . . . .	L Near	 07AC	  _TEXT	
  clip_setup_oow1  . . . . . . .	L Near	 07CC	  _TEXT	
  clip_setup_oow1_inc  . . . . .	L Near	 07D4	  _TEXT	
  clip_setup_stow1 . . . . . . .	L Near	 07E0	  _TEXT	
  clip_setup_end . . . . . . . .	L Near	 0810	  _TEXT	
  update_fifo_ptr  . . . . . . .	L Near	 0834	  _TEXT	


Symbols:

                N a m e                 Type     Value    Attr

CPUType  . . . . . . . . . . . .	Number	 0010h	 
CoordinateSpace  . . . . . . . .	Number	 0D98h	 
GDBG_INFO_ON . . . . . . . . . .	Text   	 
GLIDE_ALT_TAB  . . . . . . . . .	Text   	 
GLIDE_DEBUG  . . . . . . . . . .	Text   	 
GLIDE_INIT_HWC . . . . . . . . .	Text   	 
GLIDE_PACKED_RGB . . . . . . . .	Text   	 0
GLIDE_TRI_CULLING  . . . . . . .	Text   	 1
MM0  . . . . . . . . . . . . . .	Text   	 MM(0)
MM1  . . . . . . . . . . . . . .	Text   	 MM(1)
MM2  . . . . . . . . . . . . . .	Text   	 MM(2)
MM3  . . . . . . . . . . . . . .	Text   	 MM(3)
MM4  . . . . . . . . . . . . . .	Text   	 MM(4)
MM5  . . . . . . . . . . . . . .	Text   	 MM(5)
MM6  . . . . . . . . . . . . . .	Text   	 MM(6)
MM7  . . . . . . . . . . . . . .	Text   	 MM(7)
Mm0  . . . . . . . . . . . . . .	Text   	 MM(0)
Mm1  . . . . . . . . . . . . . .	Text   	 MM(1)
Mm2  . . . . . . . . . . . . . .	Text   	 MM(2)
Mm3  . . . . . . . . . . . . . .	Text   	 MM(3)
Mm4  . . . . . . . . . . . . . .	Text   	 MM(4)
Mm5  . . . . . . . . . . . . . .	Text   	 MM(5)
Mm6  . . . . . . . . . . . . . .	Text   	 MM(6)
Mm7  . . . . . . . . . . . . . .	Text   	 MM(7)
SIZEOF_GC  . . . . . . . . . . .	Number	 9714h	 
SIZEOF_GlideRoot . . . . . . . .	Number	 000BCFC4h   
SIZEOF_GrState . . . . . . . . .	Number	 0BBCh	 
_F1  . . . . . . . . . . . . . .	DWord	 0000	  CONST	
_F256  . . . . . . . . . . . . .	DWord	 0004	  CONST	
_VPF1  . . . . . . . . . . . . .	DWord	 0008	  CONST	
_VPF256  . . . . . . . . . . . .	DWord	 000C	  CONST	
__GlideRoot  . . . . . . . . . .	DWord	 0000	  External
__grCommandTransportMakeRoom@12 	L Near	 0000	  External
__grValidateState  . . . . . . .	L Near	 0000	  External
_count . . . . . . . . . . . . .	Number	 0020h	 
_mode  . . . . . . . . . . . . .	Number	 001Ch	 
_pktype  . . . . . . . . . . . .	Number	 0014h	 
_pointers  . . . . . . . . . . .	Number	 0024h	 
_type  . . . . . . . . . . . . .	Number	 0018h	 
_va  . . . . . . . . . . . . . .	Number	 0014h	 
_vb  . . . . . . . . . . . . . .	Number	 0018h	 
_vc  . . . . . . . . . . . . . .	Number	 001Ch	 
bInfo  . . . . . . . . . . . . .	Number	 011Ch	 
base_ptr . . . . . . . . . . . .	Number	 0074h	 
ccoow  . . . . . . . . . . . . .	DWord	 0004	  _DATA	
checkPtr . . . . . . . . . . . .	Number	 96ACh	 
colorType  . . . . . . . . . . .	Number	 0B74h	 
cullStripHdr . . . . . . . . . .	Number	 0DDCh	 
cull_mode  . . . . . . . . . . .	Number	 01E0h	 
curTriSize . . . . . . . . . . .	Number	 004Ch	 
current_sst  . . . . . . . . . .	Number	 000Ch	 
depth_range  . . . . . . . . . .	Number	 0A44h	 
dlp  . . . . . . . . . . . . . .	Text   	 ebp
drawTrianglesProc  . . . . . . .	Number	 0DC8h	 
drawVertexList . . . . . . . . .	Number	 0DC4h	 
fbi_fbzMode  . . . . . . . . . .	Number	 0210h	 
fifoEnd  . . . . . . . . . . . .	Number	 0E08h	 
fifoJmpHdr . . . . . . . . . . .	Number	 0E14h	 
fifoOffset . . . . . . . . . . .	Number	 0E0Ch	 
fifoPtr  . . . . . . . . . . . .	Number	 0DE4h	 
fifoRead . . . . . . . . . . . .	Number	 0DE8h	 
fifoRoom . . . . . . . . . . . .	Number	 0DECh	 
fifoSize . . . . . . . . . . . .	Number	 0E10h	 
fifoStart  . . . . . . . . . . .	Number	 0E04h	 
fifo . . . . . . . . . . . . . .	Text   	 ecx
fogInfo_mode . . . . . . . . . .	Number	 0B2Ch	 
fogInfo_offset . . . . . . . . .	Number	 0B30h	 
gc . . . . . . . . . . . . . . .	Text   	 esi
invalid  . . . . . . . . . . . .	Number	 0B78h	 
lfbLockCount . . . . . . . . . .	Number	 0E24h	 
lfb_ptr  . . . . . . . . . . . .	Number	 0080h	 
lostContext  . . . . . . . . . .	Number	 96BCh	 
mM0  . . . . . . . . . . . . . .	Text   	 MM(0)
mM1  . . . . . . . . . . . . . .	Text   	 MM(1)
mM2  . . . . . . . . . . . . . .	Text   	 MM(2)
mM3  . . . . . . . . . . . . . .	Text   	 MM(3)
mM4  . . . . . . . . . . . . . .	Text   	 MM(4)
mM5  . . . . . . . . . . . . . .	Text   	 MM(5)
mM6  . . . . . . . . . . . . . .	Text   	 MM(6)
mM7  . . . . . . . . . . . . . .	Text   	 MM(7)
mm0  . . . . . . . . . . . . . .	Text   	 MM(0)
mm1  . . . . . . . . . . . . . .	Text   	 MM(1)
mm2  . . . . . . . . . . . . . .	Text   	 MM(2)
mm3  . . . . . . . . . . . . . .	Text   	 MM(3)
mm4  . . . . . . . . . . . . . .	Text   	 MM(4)
mm5  . . . . . . . . . . . . . .	Text   	 MM(5)
mm6  . . . . . . . . . . . . . .	Text   	 MM(6)
mm7  . . . . . . . . . . . . . .	Text   	 MM(7)
oowa . . . . . . . . . . . . . .	DWord	 0010	  _DATA	
p6Fencer . . . . . . . . . . . .	Number	 0000h	 
packetVal  . . . . . . . . . . .	DWord	 0008	  _DATA	
paramIndex . . . . . . . . . . .	Number	 01E4h	 
paramMask  . . . . . . . . . . .	Number	 0DE0h	 
pool_f1  . . . . . . . . . . . .	Number	 0028h	 
pool_f255  . . . . . . . . . . .	Number	 002Ch	 
q0Info_mode  . . . . . . . . . .	Number	 0B5Ch	 
q0Info_offset  . . . . . . . . .	Number	 0B60h	 
q1Info_mode  . . . . . . . . . .	Number	 0B64h	 
q1Info_offset  . . . . . . . . .	Number	 0B68h	 
qInfo_mode . . . . . . . . . . .	Number	 0B54h	 
qInfo_offset . . . . . . . . . .	Number	 0B58h	 
reg_ptr  . . . . . . . . . . . .	Number	 0078h	 
roomToEnd  . . . . . . . . . . .	Number	 0E20h	 
roomToReadPtr  . . . . . . . . .	Number	 0E1Ch	 
strideinbytes  . . . . . . . . .	DWord	 000C	  _DATA	
tlsOffset  . . . . . . . . . . .	Number	 0008h	 
tmu0_s_scale . . . . . . . . . .	Number	 0A0Ch	 
tmu0_t_scale . . . . . . . . . .	Number	 0A10h	 
tmu1_s_scale . . . . . . . . . .	Number	 0A28h	 
tmu1_t_scale . . . . . . . . . .	Number	 0A2Ch	 
triPacketHdr . . . . . . . . . .	Number	 0DD8h	 
triSetupProc . . . . . . . . . .	Number	 0DC4h	 
trisDrawn  . . . . . . . . . . .	Number	 0010h	 
trisProcessed  . . . . . . . . .	Number	 000Ch	 
tsuDataList  . . . . . . . . . .	Number	 0124h	 
vPtr0  . . . . . . . . . . . . .	DWord	 0014	  _DATA	
vPtr1  . . . . . . . . . . . . .	DWord	 0018	  _DATA	
vPtr2  . . . . . . . . . . . . .	DWord	 001C	  _DATA	
vSize  . . . . . . . . . . . . .	DWord	 0000	  _DATA	
vertexCount  . . . . . . . . . .	Text   	 ebx
vertexPtr  . . . . . . . . . . .	Text   	 edi
vertexSize . . . . . . . . . . .	Number	 0B70h	 
vertexStride . . . . . . . . . .	Number	 0B6Ch	 
vp_hdepth  . . . . . . . . . . .	Number	 0B08h	 
vp_hheight . . . . . . . . . . .	Number	 0B04h	 
vp_hwidth  . . . . . . . . . . .	Number	 0B00h	 
vp_ox  . . . . . . . . . . . . .	Number	 0AF4h	 
vp_oy  . . . . . . . . . . . . .	Number	 0AF8h	 
vp_oz  . . . . . . . . . . . . .	Number	 0AFCh	 
wInfo_offset . . . . . . . . . .	Number	 0B20h	 
windowed . . . . . . . . . . . .	Number	 96C4h	 

	   0 Warnings
	   0 Errors
